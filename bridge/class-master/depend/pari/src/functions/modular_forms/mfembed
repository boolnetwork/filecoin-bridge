Function: mfembed
Section: modular_forms
C-Name: mfembed0
Prototype: GDGp
Help: mfembed(f,{v}):
 if v is omitted, f must be a modular form or a modular form
 space with parameters [N,k,chi] and we return a vector of complex
 embeddings of Q(f) or Q(chi), respectively.

 If v is given, it must be a scalar in Q(f), or a vector/matrix of such,
 we apply the embeddings coefficientwise and return a vector of results.
 Finally f can be replaced by a single embedding produced by mfembed(f)
 and we apply that particular embedding to v. Note that, in our context,
 Q(chi) has a single canonical embeding given by s: Mod(t, polcyclo(n,t))
 -> exp(2*I*Pi/n) and Q(f) has [Q(f):Q(chi)] induced embeddings attached
 to the complex roots of s(P) where P = mfparams(f)[4], as ordered by
 polroots. In the latter case, we only support an f with Q(f) = Q(chi) or
 an eigenform produced by mfeigenbasis.

Doc: let $f$ be a generalized modular form with parameters $[N,k,\chi,P]$ (see
 \kbd{mfparams}, we denote $\Q(\chi)$ the subfield of $\C$ generated by the
 values of $\chi$ and $\Q(f)$ the field of definition of $f$. In this context
 $\Q(\chi)$ has a single canonical complex embeding given by
 $s: \kbd{Mod(t, polcyclo(n,t))} \mapsto \exp(2i\pi/n)$ and the number field
 $\Q(f)$ has $[\Q(f):\Q(\chi)]$ induced embeddings attached to the complex
 roots of the polynomial $s(P)$. If $\Q(f)$ is stricly larger than $\Q(\chi)$
 we only allow an $f$ which is an eigenform, produced by \kbd{mfeigenbasis}.

 This function is meant to create embeddings of $\Q(f)$ and/or apply them
 to the object $v$, typically a vector of Fourier coefficients of $f$
 from \kbd{mfcoefs}.

 \item If $v$ is omitted and $f$ is a modular form as above, we return the
 embedding of $\Q(\chi)$ if $\Q(\chi) = \Q(f)$ and a vector containing
 $[\Q(f):\Q(\chi)]$ embeddings of $\Q(f)$ otherwise.

 \item If $v$ is given, it must be a scalar in $\Q(f)$, or a vector/matrix of
 such, we apply the embeddings coefficientwise and return either
 a single result if $\Q(f) = \Q(\chi)$ and a vector of $[\Q(f):\Q(\chi)]$
 results otherwise.

 \item Finally $f$ can be replaced by a single embedding produced by
 \kbd{mfembed}$(f)$ ($v$ was omitted) and we apply that particular embedding
 to $v$.

 \bprog
 ? mf = mfinit([35,2,Mod(11,35)], 0);
 ? [f] = mfbasis(mf);
 ? f.mod  \\@com $\Q(\chi) = \Q(\zeta_3)$
 %3 = t^2 + t + 1
 ? v = mfcoefs(f,5); lift(v)  \\@com coefficients in $\Q(\chi)$
 %4 = [0, 2, -2*t - 2, 2*t, 2*t, -2*t - 2]
 ? mfembed(f, v)   \\ single embedding
 %5 = [0, 2, -1 - 1.7320...*I, -1 + 1.73205...*I, -1 + 1.7320...*I, ...]

 ? [F] = mfeigenbasis(mf);
 ? mffields(mf)
 %7 = [y^2 + Mod(-2*t, t^2 + t + 1)]   \\@com $[\Q(f):\Q(\chi)] = 2$
 ? V = liftpol( mfcoefs(F,5) );
 %8 = [0, 1, y + (-t - 1), (t + 1)*y + t, (-2*t - 2)*y + t, -t - 1]
 ? vall = mfembed(F, V); #vall
 %9 = 2    \\ 2 embeddings, both applied to V
 ? vall[1] \\ the first
 %10 = [0, 1, -1.2071... - 2.0907...*I, 0.2071... - 0.3587...*I, ...]
 ? vall[2] \\ and the second one
 %11 = [0, 1, 0.2071... + 0.3587...*I, -1.2071... + 2.0907...*I, ...]

 ? vE = mfembed(F); #vE   \\ same 2 embeddings
 %12 = 2
 ? mfembed(vE[1], V)  \\ apply first embedding to V
 %13 = [0, 1, -1.2071... - 2.0907...*I, 0.2071... - 0.3587...*I, ...]
 @eprog

 For convenience, we also allow a modular form space from \kbd{mfinit}
 instead of $f$, corresponding to the single embedding of $\Q(\chi)$.
 \bprog
 ? [mfB,MC,C] = mfatkininit(mf,7); MC  \\@com coefs in $\Q(\chi)$
 %13 =
 [       Mod(2/7*t, t^2 + t + 1) Mod(-1/7*t - 2/7, t^2 + t + 1)]

 [Mod(-1/7*t - 2/7, t^2 + t + 1)        Mod(2/7*t, t^2 + t + 1)]

 ? C   \\ normalizing constant
 %14 = 0.33863... - 0.16787*I
 ? M = mfembed(mf, MC) / C  \\ the true matrix for the action of w_7
 [-0.6294... + 0.4186...*I -0.3625... - 0.5450...*I]

 [-0.3625... - 0.5450...*I -0.6294... + 0.4186...*I]

 ? exponent(M*conj(M) - 1)   \\ M * conj(M) is close to 1
 %16 = -126
 @eprog
