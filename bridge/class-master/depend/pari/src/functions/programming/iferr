Function: _iferr_CATCH
Class: gp2c_internal
Description:
  (0)               pari_CATCH(CATCH_ALL)
  (small)           pari_CATCH2(__iferr_old$1, CATCH_ALL)

Function: _iferr_ENDCATCH
Class: gp2c_internal
Description:
  (0)        pari_ENDCATCH
  (small)    pari_ENDCATCH2(__iferr_old$1)

Function: _iferr_CATCH_reset
Class: gp2c_internal
Description:
  (0):void      pari_CATCH_reset()
  (small):void  pari_CATCH2_reset(__iferr_old$1)

Function: _iferr_error
Class: gp2c_internal
Description:
  ():error pari_err_last()

Function: _iferr_rethrow
Class: gp2c_internal
Description:
  (error):void    pari_err(0, $1)

Function: iferr
Section: programming/control
C-Name: iferrpari
Prototype: EVEDE
Help: iferr(seq1,E,seq2,{pred}): evaluates the expression sequence seq1. If
 an error occurs, set the formal parameter E set to the error data.
 If pred is not present or evaluates to true, catch the error and evaluate
 seq2. Both pred and seq2 can reference E.
Doc: evaluates the expression sequence \var{seq1}. If an error occurs,
 set the formal parameter \var{E} set to the error data.
 If \var{pred} is not present or evaluates to true, catch the error
 and evaluate \var{seq2}. Both \var{pred} and \var{seq2} can reference \var{E}.
 The error type is given by \kbd{errname(E)}, and other data can be
 accessed using the \tet{component} function. The code \var{seq2} should check
 whether the error is the one expected. In the negative the error can be
 rethrown using \tet{error(E)} (and possibly caught by an higher \kbd{iferr}
 instance). The following uses \kbd{iferr} to implement Lenstra's ECM factoring
  method
 \bprog
 ? ecm(N, B = 1000!, nb = 100)=
   {
     for(a = 1, nb,
       iferr(ellmul(ellinit([a,1]*Mod(1,N)), [0,1]*Mod(1,N), B),
         E, return(gcd(lift(component(E,2)),N)),
         errname(E)=="e_INV" && type(component(E,2)) == "t_INTMOD"))
   }
 ? ecm(2^101-1)
 %2 = 7432339208719
 @eprog
 The return value of \kbd{iferr} itself is the value of \var{seq2} if an
 error occurs, and the value of \var{seq1} otherwise. We now describe the
 list of valid error types, and the attached error data \var{E}; in each
 case, we list in order the components of \var{E}, accessed via
 \kbd{component(E,1)}, \kbd{component(E,2)}, etc.

  \misctitle{Internal errors, ``system'' errors}

  \item \kbd{"e\_ARCH"}. A requested feature $s$ is not available on this
  architecture or operating system.
  \var{E} has one component (\typ{STR}): the missing feature name $s$.

  \item \kbd{"e\_BUG"}. A bug in the PARI library, in function $s$.
  \var{E} has one component (\typ{STR}): the function name $s$.

  \item \kbd{"e\_FILE"}. Error while trying to open a file.
  \var{E} has two components, 1 (\typ{STR}): the file type (input, output,
  etc.), 2 (\typ{STR}): the file name.

  \item \kbd{"e\_IMPL"}. A requested feature $s$ is not implemented.
  \var{E} has one component, 1 (\typ{STR}): the feature name $s$.

  \item \kbd{"e\_PACKAGE"}. Missing optional package $s$.
  \var{E} has one component, 1 (\typ{STR}): the package name $s$.

  \misctitle{Syntax errors, type errors}

  \item \kbd{"e\_DIM"}. The dimensions of arguments $x$ and $y$ submitted
  to function $s$ does not match up.
  E.g., multiplying matrices of inconsistent dimension, adding vectors of
  different lengths,\dots
  \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2: the
  argument $x$, 3: the argument $y$.

  \item \kbd{"e\_FLAG"}. A flag argument is out of bounds in function $s$.
  \var{E} has one component, 1 (\typ{STR}): the function name $s$.

  \item \kbd{"e\_NOTFUNC"}. Generated by the PARI evaluator; tried to use a
 \kbd{GEN} $x$ which is not a \typ{CLOSURE} in a function call syntax (as in
 \kbd{f = 1; f(2);}).
  \var{E} has one component, 1: the offending \kbd{GEN} $x$.

  \item \kbd{"e\_OP"}. Impossible operation between two objects than cannot
  be typecast to a sensible common domain for deeper reasons than a type
  mismatch, usually for arithmetic reasons. As in \kbd{O(2) + O(3)}: it is
  valid to add two \typ{PADIC}s, provided the underlying prime is the same; so
  the addition is not forbidden a priori for type reasons, it only becomes so
  when inspecting the objects and trying to perform the operation.
  \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
  2: first argument, 3: second argument.

  \item \kbd{"e\_TYPE"}. An argument $x$ of function $s$ had an unexpected type.
  (As in \kbd{factor("blah")}.)
  \var{E} has two components, 1 (\typ{STR}): the function name $s$,
  2: the offending argument $x$.

  \item \kbd{"e\_TYPE2"}. Forbidden operation between two objects than cannot be
  typecast to a sensible common domain, because their types do not match up.
  (As in \kbd{Mod(1,2) + Pi}.)
  \var{E} has three components, 1 (\typ{STR}): the operator name \var{op},
  2: first argument, 3: second argument.

  \item \kbd{"e\_PRIORITY"}. Object $o$ in function $s$ contains
  variables whose priority is incompatible with the expected operation.
  E.g.~\kbd{Pol([x,1], 'y)}: this raises an error because it's not possible to
  create a polynomial whose coefficients involve variables with higher priority
  than the main variable. $E$ has four components: 1 (\typ{STR}): the function
  name $s$, 2: the offending argument $o$, 3 (\typ{STR}): an operator
  $\var{op}$ describing the priority error, 4 (\typ{POL}):
  the variable $v$ describing the priority error. The argument
  satisfies $\kbd{variable}(x)~\var{op} \kbd{variable}(v)$.

  \item \kbd{"e\_VAR"}. The variables of arguments $x$ and $y$ submitted
  to function $s$ does not match up. E.g., considering the algebraic number
  \kbd{Mod(t,t\pow2+1)} in \kbd{nfinit(x\pow2+1)}.
  \var{E} has three component, 1 (\typ{STR}): the function name $s$, 2
  (\typ{POL}): the argument $x$, 3 (\typ{POL}): the argument $y$.

  \misctitle{Overflows}

  \item \kbd{"e\_COMPONENT"}. Trying to access an inexistent component in a
  vector/matrix/list in a function: the index is less than $1$ or greater
  than the allowed length.
  \var{E} has four components,
  1 (\typ{STR}): the function name
  2 (\typ{STR}): an operator $\var{op}$ ($<$ or $>$),
  2 (\typ{GEN}): a numerical limit $l$ bounding the allowed range,
  3 (\kbd{GEN}): the index $x$. It satisfies $x$ \var{op} $l$.

  \item \kbd{"e\_DOMAIN"}. An argument is not in the function's domain.
  \var{E} has five components, 1 (\typ{STR}): the function name,
  2 (\typ{STR}): the mathematical name of the out-of-domain argument
  3 (\typ{STR}): an operator $\var{op}$ describing the domain error,
  4 (\typ{GEN}): the numerical limit $l$ describing the domain error,
  5 (\kbd{GEN}): the out-of-domain argument $x$. The argument satisfies $x$
  \var{op} $l$, which prevents it from belonging to the function's domain.

  \item \kbd{"e\_MAXPRIME"}. A function using the precomputed list of prime
  numbers ran out of primes.
  \var{E} has one component, 1 (\typ{INT}): the requested prime bound, which
  overflowed \kbd{primelimit} or $0$ (bound is unknown).

  \item \kbd{"e\_MEM"}. A call to \tet{pari_malloc} or \tet{pari_realloc}
  failed. \var{E} has no component.

  \item \kbd{"e\_OVERFLOW"}. An object in function $s$ becomes too large to be
  represented within PARI's hardcoded limits. (As in \kbd{2\pow2\pow2\pow10} or
  \kbd{exp(1e100)}, which overflow in \kbd{lg} and \kbd{expo}.)
  \var{E} has one component, 1 (\typ{STR}): the function name $s$.

  \item \kbd{"e\_PREC"}. Function $s$ fails because input accuracy is too low.
  (As in \kbd{floor(1e100)} at default accuracy.)
  \var{E} has one component, 1 (\typ{STR}): the function name $s$.

  \item \kbd{"e\_STACK"}. The PARI stack overflows.
  \var{E} has no component.

  \misctitle{Errors triggered intentionally}

  \item \kbd{"e\_ALARM"}. A timeout, generated by the \tet{alarm} function.
  \var{E} has one component (\typ{STR}): the error message to print.

  \item \kbd{"e\_USER"}. A user error, as triggered by
  \tet{error}($g_1,\dots,g_n)$.
  \var{E} has one component, 1 (\typ{VEC}): the vector of $n$ arguments given
  to \kbd{error}.

  \misctitle{Mathematical errors}

  \item \kbd{"e\_CONSTPOL"}. An argument of function $s$ is a constant
  polynomial, which does not make sense. (As in \kbd{galoisinit(Pol(1))}.)
  \var{E} has one component, 1 (\typ{STR}): the function name $s$.

  \item \kbd{"e\_COPRIME"}. Function $s$ expected coprime arguments,
  and did receive $x,y$, which were not.
  \var{E} has three component, 1 (\typ{STR}): the function name $s$,
  2: the argument $x$, 3: the argument $y$.

  \item \kbd{"e\_INV"}. Tried to invert a non-invertible object $x$ in
  function $s$.
  \var{E} has two components, 1 (\typ{STR}): the function name $s$,
  2: the non-invertible $x$. If $x = \kbd{Mod}(a,b)$
  is a \typ{INTMOD} and $a$ is not $0$ mod $b$, this allows to factor
  the modulus, as \kbd{gcd}$(a,b)$ is a non-trivial divisor of $b$.

  \item \kbd{"e\_IRREDPOL"}. Function $s$ expected an irreducible polynomial,
  and did receive $T$, which was not. (As in \kbd{nfinit(x\pow2-1)}.)
  \var{E} has two component, 1 (\typ{STR}): the function name $s$,
  2 (\typ{POL}): the polynomial $x$.

  \item \kbd{"e\_MISC"}. Generic uncategorized error.
  \var{E} has one component (\typ{STR}): the error message to print.

  \item \kbd{"e\_MODULUS"}. moduli $x$ and $y$ submitted to function $s$ are
  inconsistent. As in
  \bprog
    nfalgtobasis(nfinit(t^3-2), Mod(t,t^2+1)
  @eprog\noindent
  \var{E} has three component, 1 (\typ{STR}): the function $s$,
  2: the argument $x$, 3: the argument $x$.

  \item \kbd{"e\_PRIME"}. Function $s$ expected a prime number,
  and did receive $p$, which was not. (As in \kbd{idealprimedec(nf, 4)}.)
  \var{E} has two component, 1 (\typ{STR}): the function name $s$,
  2: the argument $p$.

  \item \kbd{"e\_ROOTS0"}. An argument of function $s$ is a zero polynomial,
  and we need to consider its roots. (As in \kbd{polroots(0)}.) \var{E} has
  one component, 1 (\typ{STR}): the function name $s$.

  \item \kbd{"e\_SQRTN"}. Trying to compute an $n$-th root of $x$, which does
  not exist, in function $s$. (As in \kbd{sqrt(Mod(-1,3))}.)
  \var{E} has two components, 1 (\typ{STR}): the function name $s$,
  2: the argument $x$.
