/* This file is autogenerated from the database. */
/* See src/desc/gen_proto */
/* Do not edit*/
entree functions_basic[]={
{"!_",0,(void*)gnot,18,"G","!a: boolean operator \"not\"."},
{"#_",0,(void*)glength,18,"lG","#x: number of non code words in x, number of characters for a string."},
{"%",0,(void*)pari_get_hist,18,"D0,L,","last history item."},
{"%#",0,(void*)pari_get_histtime,18,"lD0,L,","time to compute last history item."},
{"+_",0,NULL,18,NULL,"+_: copy and return its argument"},
{"-_",0,(void*)gneg,18,"G","-_: negate argument"},
{"Catalan",0,(void*)mpcatalan,8,"p","Catalan=Catalan(): Catalan's number with current precision."},
{"Col",0,(void*)gtocol0,3,"GD0,L,","Col(x, {n}): transforms the object x into a column vector of dimension n."},
{"Colrev",0,(void*)gtocolrev0,3,"GD0,L,","Colrev(x, {n}): transforms the object x into a column vector of dimension n in reverse order with respect to Col(x, {n}). Empty vector if x is omitted."},
{"Euler",0,(void*)mpeuler,8,"p","Euler=Euler(): Euler's constant with current precision."},
{"I",0,(void*)gen_I,8,"","I=I(): square root of -1."},
{"List",0,(void*)gtolist,3,"DG","List({x=[]}): transforms the vector or list x into a list. Empty list if x is omitted."},
{"Map",0,(void*)gtomap,3,"DG","Map({x}): converts the matrix [a_1,b_1;a_2,b_2;...;a_n,b_n] to the map a_i->b_i."},
{"Mat",0,(void*)gtomat,3,"DG","Mat({x=[]}): transforms any GEN x into a matrix. Empty matrix if x is omitted."},
{"Mod",0,(void*)gmodulo,3,"GG","Mod(a,b): creates 'a modulo b'."},
{"O",0,(void*)ggrando,6,"","O(p^e): p-adic or power series zero with precision given by e."},
{"O(_^_)",0,(void*)ggrando,20,"GD1,L,","O(p^e): p-adic or power series zero with precision given by e."},
{"Pi",0,(void*)mppi,8,"p","Pi=Pi(): the constant pi, with current precision."},
{"Pol",0,(void*)gtopoly,3,"GDn","Pol(t,{v='x}): convert t (usually a vector or a power series) into a polynomial with variable v, starting with the leading coefficient."},
{"Polrev",0,(void*)gtopolyrev,3,"GDn","Polrev(t,{v='x}): convert t (usually a vector or a power series) into a polynomial with variable v, starting with the constant term."},
{"Qfb",0,(void*)Qfb0,3,"GGGDGp","Qfb(a,b,c,{D=0.}): binary quadratic form a*x^2+b*x*y+c*y^2. D is optional (0.0 by default) and initializes Shanks's distance if b^2-4*a*c>0."},
{"Ser",0,(void*)Ser0,3,"GDnDGDP","Ser(s,{v='x},{d=seriesprecision}): convert s into a power series with variable v and precision d, starting with the constant coefficient."},
{"Set",0,(void*)gtoset,3,"DG","Set({x=[]}): convert x into a set, i.e. a row vector with strictly increasing coefficients. Empty set if x is omitted."},
{"Str",0,(void*)Str,3,"s*","Str({x}*): concatenates its (string) argument into a single string."},
{"Strchr",0,(void*)Strchr,3,"G","Strchr(x): converts x to a string, translating each integer into a character."},
{"Strexpand",0,(void*)Strexpand,3,"s*","Strexpand({x}*): concatenates its (string) argument into a single string, performing tilde expansion."},
{"Strprintf",0,(void*)Strprintf,1,"ss*","Strprintf(fmt,{x}*): returns a string built from the remaining arguments according to the format fmt."},
{"Strtex",0,(void*)Strtex,3,"s*","Strtex({x}*): translates its (string) arguments to TeX format and returns the resulting string."},
{"Vec",0,(void*)gtovec0,3,"GD0,L,","Vec(x, {n}): transforms the object x into a vector of dimension n."},
{"Vecrev",0,(void*)gtovecrev0,3,"GD0,L,","Vecrev(x, {n}): transforms the object x into a vector of dimension n in reverse order with respect to Vec(x, {n})."},
{"Vecsmall",0,(void*)gtovecsmall0,3,"GD0,L,","Vecsmall(x, {n}): transforms the object x into a VECSMALL of dimension n."},
{"[_.._]",0,(void*)vecrange,20,"GG","[a..b] = [a,a+1,...,b]"},
{"[_|_<-_,_;_]",0,(void*)vecexpr1,20,"mGVDEDE","[a(x)|x<-b,c(x);...]"},
{"[_|_<-_,_]",0,(void*)vecexpr0,20,"GVDEDE","[a(x)|x<-b,c(x)] = apply(a,select(c,b))"},
{"_!",0,(void*)mpfact,18,"L","n!: factorial of n."},
{"_!=_",0,(void*)gne,18,"GG","a!=b: true if a and b are not equal."},
{"_%=_",0,(void*)gmode,18,"&G","x%=y: shortcut for x=x%y."},
{"_%_",0,(void*)gmod,18,"GG","x%y: Euclidean remainder of x and y."},
{"_&&_",0,(void*)andpari,18,"GE","a&&b: boolean operator \"and\"."},
{"_'",0,(void*)deriv,18,"GDn","x': derivative of x with respect to the main variable."},
{"_(_)",0,NULL,18,NULL,"f(a,b,...): evaluate the function f on a,b,..."},
{"_*=_",0,(void*)gmule,18,"&G","x*=y: shortcut for x=x*y."},
{"_*_",0,(void*)gmul,18,"GG","x*y: product of x and y."},
{"_++",0,(void*)gadd1e,18,"&","x++: set x to x+1."},
{"_+=_",0,(void*)gadde,18,"&G","x+=y: shortcut for x=x+y."},
{"_+_",0,(void*)gadd,18,"GG","x+y: sum of x and y."},
{"_--",0,(void*)gsub1e,18,"&","x--: set x to x-1."},
{"_-=_",0,(void*)gsube,18,"&G","x-=y: shortcut for x=x-y."},
{"_-_",0,(void*)gsub,18,"GG","x-y: difference of x and y."},
{"_.a1",0,(void*)member_a1,19,"mG","_.a1"},
{"_.a2",0,(void*)member_a2,19,"mG","_.a2"},
{"_.a3",0,(void*)member_a3,19,"mG","_.a3"},
{"_.a4",0,(void*)member_a4,19,"mG","_.a4"},
{"_.a6",0,(void*)member_a6,19,"mG","_.a6"},
{"_.area",0,(void*)member_area,19,"mG","_.area"},
{"_.b2",0,(void*)member_b2,19,"mG","_.b2"},
{"_.b4",0,(void*)member_b4,19,"mG","_.b4"},
{"_.b6",0,(void*)member_b6,19,"mG","_.b6"},
{"_.b8",0,(void*)member_b8,19,"mG","_.b8"},
{"_.bid",0,(void*)member_bid,19,"mG","_.bid"},
{"_.bnf",0,(void*)member_bnf,19,"mG","_.bnf"},
{"_.c4",0,(void*)member_c4,19,"mG","_.c4"},
{"_.c6",0,(void*)member_c6,19,"mG","_.c6"},
{"_.clgp",0,(void*)member_clgp,19,"mG","_.clgp"},
{"_.codiff",0,(void*)member_codiff,19,"mG","_.codiff"},
{"_.cyc",0,(void*)member_cyc,19,"mG","_.cyc"},
{"_.diff",0,(void*)member_diff,19,"mG","_.diff"},
{"_.disc",0,(void*)member_disc,19,"mG","_.disc"},
{"_.e",0,(void*)member_e,19,"mG","_.e"},
{"_.eta",0,(void*)member_eta,19,"mG","_.eta"},
{"_.f",0,(void*)member_f,19,"mG","_.f"},
{"_.fu",0,(void*)member_fu,19,"G","_.fu"},
{"_.futu",0,(void*)member_futu,19,"mG","_.futu"},
{"_.gen",0,(void*)member_gen,19,"mG","_.gen"},
{"_.group",0,(void*)member_group,19,"mG","_.group"},
{"_.index",0,(void*)member_index,19,"mG","_.index"},
{"_.j",0,(void*)member_j,19,"mG","_.j"},
{"_.mod",0,(void*)member_mod,19,"mG","_.mod"},
{"_.nf",0,(void*)member_nf,19,"mG","_.nf"},
{"_.no",0,(void*)member_no,19,"mG","_.no"},
{"_.omega",0,(void*)member_omega,19,"mG","_.omega"},
{"_.orders",0,(void*)member_orders,19,"mG","_.orders"},
{"_.p",0,(void*)member_p,19,"mG","_.p"},
{"_.pol",0,(void*)member_pol,19,"mG","_.pol"},
{"_.polabs",0,(void*)member_polabs,19,"mG","_.polabs"},
{"_.r1",0,(void*)member_r1,19,"mG","_.r1"},
{"_.r2",0,(void*)member_r2,19,"mG","_.r2"},
{"_.reg",0,(void*)member_reg,19,"mG","_.reg"},
{"_.roots",0,(void*)member_roots,19,"mG","_.roots"},
{"_.sign",0,(void*)member_sign,19,"mG","_.sign"},
{"_.t2",0,(void*)member_t2,19,"G","_.t2"},
{"_.tate",0,(void*)member_tate,19,"mG","_.tate"},
{"_.tu",0,(void*)member_tu,19,"G","_.tu"},
{"_.tufu",0,(void*)member_tufu,19,"mG","_.tufu"},
{"_.zk",0,(void*)member_zk,19,"mG","_.zk"},
{"_.zkst",0,(void*)member_zkst,19,"mG","_.zkst"},
{"_/=_",0,(void*)gdive,18,"&G","x/=y: shortcut for x=x/y."},
{"_/_",0,(void*)gdiv,18,"GG","x/y: quotient of x and y."},
{"_<<=_",0,(void*)gshiftle,18,"&L","x<<=y: shortcut for x=x<<y."},
{"_<<_",0,(void*)gshift,18,"GL","x<<y: compute shift(x,y)."},
{"_<=_",0,(void*)gle,18,"GG","x<=y: return 1 if x is less or equal to y, 0 otherwise."},
{"_<_",0,(void*)glt,18,"GG","x<y: return 1 if x is strictly less than y, 0 otherwise."},
{"_===_",0,(void*)gidentical,18,"iGG","x===y: return 1 if x and y are identical, 0 otherwise."},
{"_==_",0,(void*)geq,18,"GG","x==y: return 1 if x and y are equal, 0 otherwise."},
{"_>=_",0,(void*)gge,18,"GG","x>=y: return 1 if x is greater or equal to y, 0 otherwise."},
{"_>>=_",0,(void*)gshiftre,18,"&L","x>>=y: shortcut for x=x>>y."},
{"_>>_",0,(void*)gshift_right,18,"GL","x>>y: compute shift(x,-y)."},
{"_>_",0,(void*)ggt,18,"GG","x>y: return 1 if x is strictly greater than y, 0 otherwise."},
{"_F2xq_log_Coppersmith_worker",0,(void*)F2xq_log_Coppersmith_worker,20,"GLGG","F2xq_log_Coppersmith_worker: worker for F2xq_log_Coppersmith"},
{"_Flxq_log_Coppersmith_worker",0,(void*)Flxq_log_Coppersmith_worker,20,"GLGG","Flxq_log_Coppersmith_worker: worker for Flxq_log_Coppersmith"},
{"_Fp_log_sieve_worker",0,(void*)Fp_log_sieve_worker,20,"LLGGGGGG","Fp_log_sieve_worker: worker for Fp_log_sieve"},
{"_ZM_det_worker",0,(void*)ZM_det_worker,20,"GG","worker for ZM_det"},
{"_ZM_inv_worker",0,(void*)ZM_inv_worker,20,"GG","worker for ZM_inv"},
{"_ZX_ZXY_resultant_worker",0,(void*)ZX_ZXY_resultant_worker,20,"GGGGG","worker for ZX_ZXY_resultant"},
{"_ZX_resultant_worker",0,(void*)ZX_resultant_worker,20,"GGGG","worker for ZX_resultant"},
{"_ZabM_inv_worker",0,(void*)ZabM_inv_worker,20,"GGG","worker for ZabM_inv"},
{"_[_,]",0,NULL,18,NULL,"x[y,]: y-th row of x."},
{"_[_,_]",0,NULL,18,NULL,"x[i{,j}]: i coefficient of a vector, i,j coefficient of a matrix"},
{"_[_.._,_.._]",0,(void*)matslice0,18,"GD0,L,D0,L,D0,L,D0,L,","x[a..b,c..d] = [x[a,c],  x[a+1,c],  ...,x[b,c];                      x[a,c+1],x[a+1,c+1],...,x[b,c+1];                        ...       ...          ...                      x[a,d],  x[a+1,d]  ,...,x[b,d]]"},
{"_[_.._]",0,(void*)vecslice0,18,"GD0,L,L","x[a..b] = [x[a],x[a+1],...,x[b]]"},
{"_\\/=_",0,(void*)gdivrounde,18,"&G","x\\/=y: shortcut for x=x\\/y."},
{"_\\/_",0,(void*)gdivround,18,"GG","x\\/y: rounded Euclidean quotient of x and y."},
{"_\\=_",0,(void*)gdivente,18,"&G","x\\=y: shortcut for x=x\\y."},
{"_\\_",0,(void*)gdivent,18,"GG","x\\y: Euclidean quotient of x and y."},
{"_^_",0,(void*)gpow,18,"GGp","x^y: compute x to the power y."},
{"_^s",0,(void*)gpowgs,20,"GL","return x^n where n is a small integer"},
{"__",0,NULL,18,NULL,"__: integral concatenation of strings."},
{"_aprcl_step4_worker",0,(void*)aprcl_step4_worker,20,"UGGG","worker for isprime (APRCL step 4)"},
{"_aprcl_step6_worker",0,(void*)aprcl_step6_worker,20,"GLGGG","worker for isprime (APRCL step 6)"},
{"_derivfun",0,(void*)derivfun0,20,"GGp","_derivfun(closure,[args]) numerical derivation of closure with respect to the first variable at (args)."},
{"_eval_mnemonic",0,(void*)eval_mnemonic,20,"lGs","Convert a mnemonic string to a flag."},
{"_factor_Aurifeuille",0,(void*)factor_Aurifeuille,20,"GL","_factor_Aurifeuille(a,d): return an algebraic factor of Phi_d(a), a != 0"},
{"_factor_Aurifeuille_prime",0,(void*)factor_Aurifeuille_prime,20,"GL","_factor_Aurifeuille_prime(p,d): return an algebraic factor of Phi_d(p), p prime"},
{"_multi_if",0,(void*)ifpari_multi,20,"GE*","internal variant of if() that allows more than 3 arguments."},
{"_nxMV_polint_worker",0,(void*)nxMV_polint_center_tree_worker,20,"GGGGG","used for parallel chinese"},
{"_pareval_worker",0,(void*)pareval_worker,20,"G","_pareval_worker(C): evaluate the closure C."},
{"_parfor_worker",0,(void*)parfor_worker,20,"GG","_parfor_worker(i,C): evaluate the closure C on i and return [i,C(i)]"},
{"_parselect_worker",0,(void*)parselect_worker,20,"GG","_parselect_worker(d,C): evaluate the boolean closure C on d."},
{"_parvector_worker",0,(void*)parvector_worker,20,"GG","_parvector_worker(i,C): evaluate the closure C on i."},
{"_polint_worker",0,(void*)nmV_polint_center_tree_worker,20,"GGGGG","used for parallel chinese"},
{"_polmodular_worker",0,(void*)polmodular_worker,20,"UUUGGGGLGG","used by polmodular"},
{"_safecoeff",0,NULL,18,NULL,"safe version of x[a], x[,a] and x[a,b]. Must be lvalues."},
{"_void_if",0,(void*)ifpari_void,20,"vGDIDI","internal variant of if() that does not return a value."},
{"_||_",0,(void*)orpari,18,"GE","a||b: boolean operator \"or\" (inclusive)."},
{"_~",0,(void*)gtrans,18,"G","x~: transpose of x."},
{"abs",0,(void*)gabs,8,"Gp","abs(x): absolute value (or modulus) of x."},
{"acos",0,(void*)gacos,8,"Gp","acos(x): arc cosine of x."},
{"acosh",0,(void*)gacosh,8,"Gp","acosh(x): inverse hyperbolic cosine of x."},
{"addhelp",0,(void*)addhelp,1,"vrs","addhelp(sym,str): add/change help message for the symbol sym."},
{"addprimes",0,(void*)addprimes,5,"DG","addprimes({x=[]}): add primes in the vector x to the prime table to be used in trial division. x may also be a single integer. Composite \"primes\" are NOT allowed."},
{"agm",0,(void*)agm,8,"GGp","agm(x,y): arithmetic-geometric mean of x and y."},
{"alarm",0,(void*)gp_alarm,1,"D0,L,DE","alarm({s = 0},{code}): if code is omitted, trigger an \"e_ALARM\" exception after s seconds, cancelling any previously set alarm; stop a pending alarm if s = 0 or is omitted. Otherwise, evaluate code, aborting after s seconds."},
{"algadd",0,(void*)algadd,11,"GGG","algadd(al,x,y): element x+y in al."},
{"algalgtobasis",0,(void*)algalgtobasis,11,"GG","algalgtobasis(al,x): transforms the element x of the algebra al into a column vector on the integral basis of al."},
{"algaut",0,(void*)algaut,11,"mG","algaut(al): the stored automorphism of the splitting field of the cyclic algebra al."},
{"algb",0,(void*)algb,11,"mG","algb(al): the element b of the center of the cyclic algebra al used to define it."},
{"algbasis",0,(void*)algbasis,11,"mG","algbasis(al): basis of the stored order of the central simple algebra al."},
{"algbasistoalg",0,(void*)algbasistoalg,11,"GG","algbasistoalg(al,x): transforms the column vector x on the integral basis of al into an element of al in algebraic form."},
{"algcenter",0,(void*)algcenter,11,"mG","algcenter(al): center of the algebra al."},
{"algcentralproj",0,(void*)alg_centralproj,11,"GGD0,L,","algcentralproj(al,z,{maps=0}): projections of the algebra al on the orthogonal central idempotents z[i]."},
{"algchar",0,(void*)algchar,11,"mG","algchar(al): characteristic of the algebra al."},
{"algcharpoly",0,(void*)algcharpoly,11,"GGDnD0,L,","algcharpoly(al,b,{v='x},{abs=0}): (reduced) characteristic polynomial of b in al, with respect to the variable v."},
{"algdegree",0,(void*)algdegree,11,"lG","algdegree(al): degree of the central simple algebra al."},
{"algdep",0,(void*)algdep0,7,"GLD0,L,","algdep(z,k,{flag=0}): algebraic relations up to degree n of z, using lindep([1,z,...,z^(k-1)], flag)."},
{"algdim",0,(void*)algdim,11,"lGD0,L,","algdim(al,{abs=0}): dimension of the algebra al."},
{"algdisc",0,(void*)algdisc,11,"G","algdisc(al): discriminant of the stored order of the algebra al."},
{"algdivl",0,(void*)algdivl,11,"GGG","algdivl(al,x,y): element x\\y in al."},
{"algdivr",0,(void*)algdivr,11,"GGG","algdivr(al,x,y): element x/y in al."},
{"alggroup",0,(void*)alggroup,11,"GDG","alggroup(gal, {p=0}): constructs the group algebra of gal over Q (resp. Fp)."},
{"alggroupcenter",0,(void*)alggroupcenter,11,"GDGD&","alggroupcenter(gal,{p=0},{&cc}): constructs the center of the group algebra of gal over Q (resp. Fp), and sets cc to the conjugacy classes of gal."},
{"alghasse",0,(void*)alghasse,11,"GG","alghasse(al,pl): the hasse invariant of the central simple algebra al at the place pl."},
{"alghassef",0,(void*)alghassef,11,"mG","alghassef(al): the hasse invariant of the central simple algebra al at finite places."},
{"alghassei",0,(void*)alghassei,11,"mG","alghassei(al): the hasse invariant of the central simple algebra al at infinite places."},
{"algindex",0,(void*)algindex,11,"lGDG","algindex(al,{pl}): the index of the central simple algebra al. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case return the local index at the place pl instead."},
{"alginit",0,(void*)alginit,11,"GGDnD1,L,","alginit(B, C, {v}, {maxord = 1}): initializes the central simple algebra defined by data B, C. If maxord = 1, compute a maximal order."},
{"alginv",0,(void*)alginv,11,"GG","alginv(al,x): element 1/x in al."},
{"alginvbasis",0,(void*)alginvbasis,11,"mG","alginvbasis(al): basis of the natural order of the central simple algebra al in terms of the stored order."},
{"algisassociative",0,(void*)algisassociative,11,"iGD0,G,","algisassociative(mt,p=0): true (1) if the multiplication table mt is suitable for algtableinit(mt,p), false (0) otherwise."},
{"algiscommutative",0,(void*)algiscommutative,11,"iG","algiscommutative(al): test whether the algebra al is commutative."},
{"algisdivision",0,(void*)algisdivision,11,"iGDG","algisdivision(al,{pl}): tests whether the central simple algebra al is a division algebra. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally a division algebra at the place pl instead."},
{"algisdivl",0,(void*)algisdivl,11,"iGGGD&","algisdivl(al,x,y,{&z}): tests whether y is left divisible by x and sets z to the left quotient x\\y."},
{"algisinv",0,(void*)algisinv,11,"iGGD&","algisinv(al,x,{&ix}): tests whether x is invertible and sets ix to the inverse of x."},
{"algisramified",0,(void*)algisramified,11,"iGDG","algisramified(al,{pl}): tests whether the central simple algebra al is ramified, i.e. not isomorphic to a matrix ring over its center. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally ramified at the place pl instead."},
{"algissemisimple",0,(void*)algissemisimple,11,"iG","algissemisimple(al): test whether the algebra al is semisimple."},
{"algissimple",0,(void*)algissimple,11,"iGD0,L,","algissimple(al, {ss = 0}): test whether the algebra al is simple."},
{"algissplit",0,(void*)algissplit,11,"iGDG","algissplit(al,{pl}): tests whether the central simple algebra al is split, i.e. isomorphic to a matrix ring over its center. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally split at the place pl instead."},
{"alglatadd",0,(void*)alglatadd,11,"GGGD&","alglatadd(al,lat1,lat2,{&ptinter}): the sum of the lattices lat1 and lat2. If ptinter is present, set it to the intersection of the lattices."},
{"alglatcontains",0,(void*)alglatcontains,11,"iGGGD&","alglatcontains(al,lat,x,{&ptc}): tests whether the lattice lat contains the element x. If ptc is present, sets it to the coordinates of x on the basis of lat."},
{"alglatelement",0,(void*)alglatelement,11,"GGG","alglatelement(al,lat,c): returns the element of al whose coordinates on the Z-basis of lat are c."},
{"alglathnf",0,(void*)alglathnf,11,"GGD0,G,","alglathnf(al,m,{d=0}): the lattice generated by the columns of m, assuming that this lattice contains d times the integral basis of al."},
{"alglatindex",0,(void*)alglatindex,11,"GGG","alglatindex(al,lat1,lat2): the generalized index (lat2:lat1)."},
{"alglatinter",0,(void*)alglatinter,11,"GGGD&","alglatinter(al,lat1,lat2,{&ptsum}): the intersection of the lattices lat1 and lat2. If ptsum is present, sets it to the sum of the lattices."},
{"alglatlefttransporter",0,(void*)alglatlefttransporter,11,"GGG","alglatlefttransporter(al,lat1,lat2): the set of x in al such that x*lat1 is contained in lat2."},
{"alglatmul",0,(void*)alglatmul,11,"GGG","alglatmul(al,lat1,lat2): the lattice generated by the products of elements of lat1 and lat2."},
{"alglatrighttransporter",0,(void*)alglatrighttransporter,11,"GGG","alglatrighttransporter(al,lat1,lat2): the set of x in al such that lat1*x is contained in lat2."},
{"alglatsubset",0,(void*)alglatsubset,11,"iGGGD&","alglatsubset(al,lat1,lat2,{&ptindex}): tests whether lat1 is contained in lat2 and if true and ptindex is present, sets it to the index (lat2:lat1)."},
{"algmakeintegral",0,(void*)algmakeintegral,11,"GD0,L,","algmakeintegral(mt,{maps=0}): computes an integral multiplication table for an isomorphic algebra."},
{"algmul",0,(void*)algmul,11,"GGG","algmul(al,x,y): element x*y in al."},
{"algmultable",0,(void*)algmultable,11,"mG","algmultable(al): multiplication table of al over its prime subfield."},
{"algneg",0,(void*)algneg,11,"GG","algneg(al,x): element -x in al."},
{"algnorm",0,(void*)algnorm,11,"GGD0,L,","algnorm(al,x,{abs=0}): (reduced) norm of x."},
{"algpoleval",0,(void*)algpoleval,11,"GGG","algpoleval(al,T,b): T in K[X] evaluate T(b) in al."},
{"algpow",0,(void*)algpow,11,"GGG","algpow(al,x,n): element x^n in al."},
{"algprimesubalg",0,(void*)algprimesubalg,11,"G","algprimesubalg(al): prime subalgebra of the positive characteristic, semisimple algebra al."},
{"algquotient",0,(void*)alg_quotient,11,"GGD0,L,","algquotient(al,I,{maps=0}): quotient of the algebra al by the two-sided ideal I."},
{"algradical",0,(void*)algradical,11,"G","algradical(al): Jacobson radical of the algebra al."},
{"algramifiedplaces",0,(void*)algramifiedplaces,11,"G","algramifiedplaces(al): vector of the places of the center of al that ramify in al. Each place is described as an integer between 1 and r1 or as a prime ideal."},
{"algrandom",0,(void*)algrandom,11,"GG","algrandom(al,b): random element in al with coefficients in [-b,b]."},
{"algrelmultable",0,(void*)algrelmultable,11,"mG","algrelmultable(al): multiplication table of the central simple algebra al over its center."},
{"algsimpledec",0,(void*)algsimpledec,11,"GD0,L,","algsimpledec(al,{maps=0}): [J,dec] where J is the Jacobson radical of al and dec is the decomposition into simple algebras of the semisimple algebra al/J."},
{"algsplit",0,(void*)algsplit,11,"GDn","algsplit(al,{v='x}): computes an isomorphism between al and M_d(F_q)."},
{"algsplittingdata",0,(void*)algsplittingdata,11,"mG","algsplittingdata(al): data stored in the central simple algebra al to compute a splitting of al over an extension."},
{"algsplittingfield",0,(void*)algsplittingfield,11,"mG","algsplittingfield(al): the stored splitting field of the central simple algebra al."},
{"algsqr",0,(void*)algsqr,11,"GG","algsqr(al,x): element x^2 in al."},
{"algsub",0,(void*)algsub,11,"GGG","algsub(al,x,y): element x-y in al."},
{"algsubalg",0,(void*)algsubalg,11,"GG","algsubalg(al,B): subalgebra of al with basis B."},
{"algtableinit",0,(void*)algtableinit,11,"GDG","algtableinit(mt, {p=0}): initializes the associative algebra over Q (resp. Fp) defined by the multiplication table mt."},
{"algtensor",0,(void*)algtensor,11,"GGD1,L,","algtensor(al1,al2,{maxord=1}): tensor product of al1 and al2."},
{"algtomatrix",0,(void*)algtomatrix,11,"GGD0,L,","algtomatrix(al,x,{abs=1}): left multiplication table of x (table algebra or abs=1) or image of x under a splitting of al (CSA and abs=0)."},
{"algtrace",0,(void*)algtrace,11,"GGD0,L,","algtrace(al,x,{abs=0}): (reduced) trace of x."},
{"algtype",0,(void*)algtype,11,"lG","algtype(al): type of the algebra al."},
{"alias",0,(void*)alias0,1,"vrr","alias(newsym,sym): defines the symbol newsym as an alias for the symbol sym."},
{"allocatemem",0,(void*)gp_allocatemem,1,"vDG","allocatemem({s=0}): allocates a new stack of s bytes. doubles the stack if s is omitted."},
{"apply",0,(void*)apply0,1,"GG","apply(f, A): apply function f to each entry in A."},
{"arg",0,(void*)garg,8,"Gp","arg(x): argument of x, such that -pi<arg(x)<=pi."},
{"asin",0,(void*)gasin,8,"Gp","asin(x): arc sine of x."},
{"asinh",0,(void*)gasinh,8,"Gp","asinh(x): inverse hyperbolic sine of x."},
{"asympnum",0,(void*)asympnum0,9,"GD0,L,DGp","asympnum(expr,{k=20},{alpha = 1}): asymptotic expansion of expr assuming it has rational coefficients with reasonable height; k and alpha are as in limitnum."},
{"atan",0,(void*)gatan,8,"Gp","atan(x): arc tangent of x."},
{"atanh",0,(void*)gatanh,8,"Gp","atanh(x): inverse hyperbolic tangent of x."},
{"bernfrac",0,(void*)bernfrac,8,"L","bernfrac(x): Bernoulli number B_x, as a rational number."},
{"bernpol",0,(void*)bernpol,8,"LDn","bernpol(n, {v = 'x}): Bernoulli polynomial B_n, in variable v."},
{"bernreal",0,(void*)bernreal,8,"Lp","bernreal(x): Bernoulli number B_x, as a real number with the current precision."},
{"bernvec",0,(void*)bernvec,8,"L","bernvec(x): this routine is obsolete, use bernfrac repeatedly."},
{"besselh1",0,(void*)hbessel1,8,"GGp","besselh1(nu,x): H^1-bessel function of index nu and argument x."},
{"besselh2",0,(void*)hbessel2,8,"GGp","besselh2(nu,x): H^2-bessel function of index nu and argument x."},
{"besseli",0,(void*)ibessel,8,"GGp","besseli(nu,x): I-bessel function of index nu and argument x."},
{"besselj",0,(void*)jbessel,8,"GGp","besselj(nu,x): J-bessel function of index nu and argument x."},
{"besseljh",0,(void*)jbesselh,8,"GGp","besseljh(n,x): J-bessel function of index n+1/2 and argument x, where n is a non-negative integer."},
{"besselk",0,(void*)kbessel,8,"GGp","besselk(nu,x): K-bessel function of index nu and argument x."},
{"besseln",0,(void*)nbessel,8,"GGp","besseln(nu,x): N-bessel function of index nu and argument x."},
{"bestappr",0,(void*)bestappr,5,"GDG","bestappr(x, {B}): returns a rational approximation to x, whose denominator is limited by B, if present. This function applies to reals, intmods, p-adics, and rationals of course. Otherwise it applies recursively to all components."},
{"bestapprPade",0,(void*)bestapprPade,5,"GD-1,L,","bestapprPade(x, {B}): returns a rational function approximation to x. This function applies to series, polmods, and rational functions of course. Otherwise it applies recursively to all components."},
{"bestapprnf",0,(void*)bestapprnf,7,"GGDGp","bestapprnf(V,T,{rootT}): T being an integral polynomial and V being a scalar, vector, or matrix, return a reasonable approximation of V with polmods modulo T. The rootT argument, if present, must be an element of polroots(T), i.e. a root of T fixing a complex embedding of Q[x]/(T)."},
{"bezout",0,(void*)gcdext0,5,"GG","bezout(x,y): deprecated alias for gcdext."},
{"bezoutres",0,(void*)polresultantext0,6,"GGDn","bezoutres(A,B,{v}): deprecated alias for polresultantext."},
{"bigomega",0,(void*)bigomega,5,"lG","bigomega(x): number of prime divisors of x, counted with multiplicity."},
{"binary",0,(void*)binaire,3,"G","binary(x): gives the vector formed by the binary digits of x (x integer)."},
{"binomial",0,(void*)binomial0,4,"GDG","binomial(x,{k}): binomial coefficient x*(x-1)...*(x-k+1)/k! defined for k in Z and any x. If k is omitted and x an integer, return the vector [binomial(x,1),...,binomial(x,x)]."},
{"bitand",0,(void*)gbitand,3,"GG","bitand(x,y): bitwise \"and\" of two integers x and y. Negative numbers behave as if modulo big power of 2."},
{"bitneg",0,(void*)gbitneg,3,"GD-1,L,","bitneg(x,{n=-1}): bitwise negation of an integers x truncated to n bits. n=-1 means represent infinite sequences of bit 1 as negative numbers. Negative numbers behave as if modulo big power of 2."},
{"bitnegimply",0,(void*)gbitnegimply,3,"GG","bitnegimply(x,y): bitwise \"negated imply\" of two integers x and y, in other words, x BITAND BITNEG(y). Negative numbers behave as if modulo big power of 2."},
{"bitor",0,(void*)gbitor,3,"GG","bitor(x,y): bitwise \"or\" of two integers x and y. Negative numbers behave as if modulo big power of 2."},
{"bitprecision",0,(void*)bitprecision0,3,"GD0,L,","bitprecision(x,{n}): if n is present and positive, return x at precision n bits. If n is omitted, return real precision of object x in bits."},
{"bittest",0,(void*)gbittest,3,"GL","bittest(x,n): gives bit number n (coefficient of 2^n) of the integer x. Negative numbers behave as if modulo big power of 2."},
{"bitxor",0,(void*)gbitxor,3,"GG","bitxor(x,y): bitwise \"exclusive or\" of two integers x and y. Negative numbers behave as if modulo big power of 2."},
{"bnfcertify",0,(void*)bnfcertify0,10,"lGD0,L,","bnfcertify(bnf,{flag = 0}): certify the correctness (i.e. remove the GRH) of the bnf data output by bnfinit. If flag is present, only certify that the class group is a quotient of the one computed in bnf (much simpler in general)."},
{"bnfcompress",0,(void*)bnfcompress,10,"G","bnfcompress(bnf): converts bnf to a much smaller sbnf, containing the same information. Use bnfinit(sbnf) to recover a true bnf."},
{"bnfdecodemodule",0,(void*)decodemodule,10,"GG","bnfdecodemodule(nf,m): given a coded module m as in bnrdisclist, gives the true module."},
{"bnfinit",0,(void*)bnfinit0,10,"GD0,L,DGp","bnfinit(P,{flag=0},{tech=[]}): compute the necessary data for future use in ideal and unit group computations, including fundamental units if they are not too large. flag and tech are both optional. flag can be any of 0: default, 1: insist on having fundamental units. See manual for details about tech."},
{"bnfisintnorm",0,(void*)bnfisintnorm,10,"GG","bnfisintnorm(bnf,x): compute a complete system of solutions (modulo units of positive norm) of the absolute norm equation N(a)=x, where a belongs to the maximal order of big number field bnf (if bnf is not certified, this depends on GRH)."},
{"bnfisnorm",0,(void*)bnfisnorm,10,"GGD1,L,","bnfisnorm(bnf,x,{flag=1}): tries to tell whether x (in Q) is the norm of some fractional y (in bnf). Returns a vector [a,b] where x=Norm(a)*b. Looks for a solution which is a S-unit, with S a certain list of primes (in bnf) containing (among others) all primes dividing x. If bnf is known to be Galois, set flag=0 (in this case, x is a norm iff b=1). If flag is non zero the program adds to S all the primes: dividing flag if flag<0, or less than flag if flag>0. The answer is guaranteed (i.e x norm iff b=1) under GRH, if S contains all primes less than 12.log(disc(Bnf))^2, where Bnf is the Galois closure of bnf."},
{"bnfisprincipal",0,(void*)bnfisprincipal0,10,"GGD1,L,","bnfisprincipal(bnf,x,{flag=1}): bnf being output by bnfinit (with flag<=2), gives [v,alpha], where v is the vector of exponents on the class group generators and alpha is the generator of the resulting principal ideal. In particular x is principal if and only if v is the zero vector. flag is optional, whose binary digits mean 1: output [v,alpha] (only v if unset); 2: increase precision until alpha can be computed (do not insist if unset)."},
{"bnfissunit",0,(void*)bnfissunit,10,"GGG","bnfissunit(bnf,sfu,x): bnf being output by bnfinit (with flag<=2), sfu by bnfsunit, gives the column vector of exponents of x on the fundamental S-units and the roots of unity if x is an S-unit, the empty vector otherwise."},
{"bnfisunit",0,(void*)bnfisunit,10,"GG","bnfisunit(bnf,x): bnf being output by bnfinit, gives the column vector of exponents of x on the fundamental units and the roots of unity if x is a unit, the empty vector otherwise."},
{"bnflog",0,(void*)bnflog,10,"GG","bnflog(bnf, l): let bnf be attached to a number field F and let l be a prime number. Return the logarithmic l-class group Cl~_F."},
{"bnflogdegree",0,(void*)bnflogdegree,10,"GGG","bnflogdegree(nf, A, l): let A be an ideal, return exp(deg_F A) the exponential of the l-adic logarithmic degree."},
{"bnflogef",0,(void*)bnflogef,10,"GG","bnflogef(nf,pr): return [e~, f~] the logarithmic ramification and residue degrees for the maximal ideal pr."},
{"bnfnarrow",0,(void*)bnfnarrow,10,"G","bnfnarrow(bnf): given a big number field as output by bnfinit, gives as a 3-component vector the structure of the narrow class group."},
{"bnfsignunit",0,(void*)signunits,10,"G","bnfsignunit(bnf): matrix of signs of the real embeddings of the system of fundamental units found by bnfinit."},
{"bnfsunit",0,(void*)bnfsunit,10,"GGp","bnfsunit(bnf,S): compute the fundamental S-units of the number field bnf output by bnfinit, S being a list of prime ideals. res[1] contains the S-units, res[5] the S-classgroup. See manual for details."},
{"bnrL1",0,(void*)bnrL1,10,"GDGD0,L,p","bnrL1(bnr, {H}, {flag=0}): bnr being output by bnrinit and H being a square matrix defining a congruence subgroup of bnr (the trivial subgroup if omitted), for each character of bnr trivial on this subgroup, compute L(1, chi) (or equivalently the first non-zero term c(chi) of the expansion at s = 0). The binary digits of flag mean 1: if 0 then compute the term c(chi) and return [r(chi), c(chi)] where r(chi) is the order of L(s, chi) at s = 0, or if 1 then compute the value at s = 1 (and in this case, only for non-trivial characters), 2: if 0 then compute the value of the primitive L-function attached to chi, if 1 then compute the value of the L-function L_S(s, chi) where S is the set of places dividing the modulus of bnr (and the infinite places), 3: return also the characters."},
{"bnrchar",0,(void*)bnrchar,10,"GGDG","bnrchar(bnr,g,{v}): returns all characters chi on bnr.clgp such that chi(g[i]) = e(v[i]); if v is omitted, returns all characters that are trivial on the g[i]."},
{"bnrclassno",0,(void*)bnrclassno0,10,"GDGDG","bnrclassno(A,{B},{C}): relative degree of the class field defined by A,B,C. [A,{B},{C}] is of type [bnr], [bnr,subgroup], [bnf,modulus], or [bnf,modulus,subgroup]. Faster than bnrinit if only the ray class number is wanted."},
{"bnrclassnolist",0,(void*)bnrclassnolist,10,"GG","bnrclassnolist(bnf,list): if list is as output by ideallist or similar, gives list of corresponding ray class numbers."},
{"bnrconductor",0,(void*)bnrconductor0,10,"GDGDGD0,L,","bnrconductor(A,{B},{C},{flag=0}): conductor f of the subfield of the ray class field given by A,B,C. flag is optional and can be 0: default, 1: returns [f, Cl_f, H], H subgroup of the ray class group modulo f defining the extension, 2: returns [f, bnr(f), H]."},
{"bnrconductorofchar",0,(void*)bnrconductorofchar,10,"GG","bnrconductorofchar(bnr,chi): this function is obsolete, use bnrconductor."},
{"bnrdisc",0,(void*)bnrdisc0,10,"GDGDGD0,L,","bnrdisc(A,{B},{C},{flag=0}): absolute or relative [N,R1,discf] of the field defined by A,B,C. [A,{B},{C}] is of type [bnr], [bnr,subgroup], [bnf, modulus] or [bnf,modulus,subgroup], where bnf is as output by bnfinit, bnr by bnrinit, and subgroup is the HNF matrix of a subgroup of the corresponding ray class group (if omitted, the trivial subgroup). flag is optional whose binary digits mean 1: give relative data; 2: return 0 if modulus is not the conductor."},
{"bnrdisclist",0,(void*)bnrdisclist0,10,"GGDG","bnrdisclist(bnf,bound,{arch}): list of discriminants of ray class fields of all conductors up to norm bound. The ramified Archimedean places are given by arch; all possible values are taken if arch is omitted. Supports the alternative syntax bnrdisclist(bnf,list), where list is as output by ideallist or ideallistarch (with units)."},
{"bnrgaloisapply",0,(void*)bnrgaloisapply,10,"GGG","bnrgaloisapply(bnr, mat, H): apply the automorphism given by its matrix mat to the congruence subgroup H given as a HNF matrix. The matrix mat can be computed with bnrgaloismatrix."},
{"bnrgaloismatrix",0,(void*)bnrgaloismatrix,10,"GG","bnrgaloismatrix(bnr,aut): return the matrix of the action of the automorphism aut of the base field bnf.nf on the generators of the ray class field bnr.gen. aut can be given as a polynomial, or a vector of automorphisms or a galois group as output by galoisinit, in which case a vector of matrices is returned (in the later case, only for the generators aut.gen)."},
{"bnrinit",0,(void*)bnrinit0,10,"GGD0,L,","bnrinit(bnf,f,{flag=0}): given a bnf as output by bnfinit and a modulus f, initializes data linked to the ray class group structure corresponding to this module. flag is optional, and can be 0: default, 1: compute also the generators."},
{"bnrisconductor",0,(void*)bnrisconductor0,10,"lGDGDG","bnrisconductor(A,{B},{C}): returns 1 if the modulus is the conductor of the subfield of the ray class field given by A,B,C (see bnrdisc), and 0 otherwise. Slightly faster than bnrconductor if this is the only desired result."},
{"bnrisgalois",0,(void*)bnrisgalois,10,"lGGG","bnrisgalois(bnr, gal, H): check whether the class field attached to the subgroup H is Galois over the subfield of bnr.nf fixed by the Galois group gal, which can be given as output by galoisinit, or as a matrix or a vector of matrices as output by bnrgaloismatrix. The ray class field attached to bnr need to be Galois, which is not checked."},
{"bnrisprincipal",0,(void*)bnrisprincipal,10,"GGD1,L,","bnrisprincipal(bnr,x,{flag=1}): bnr being output by bnrinit and x being an ideal coprime to bnr.mod, returns [v,alpha], where v is the vector of exponents on the ray class group generators and alpha is the generator of the resulting principal ideal. If (optional) flag is set to 0, output only v."},
{"bnrrootnumber",0,(void*)bnrrootnumber,10,"GGD0,L,p","bnrrootnumber(bnr,chi,{flag=0}): returns the so-called Artin Root Number, i.e. the constant W appearing in the functional equation of the Hecke L-function attached to chi. Set flag = 1 if the character is known to be primitive."},
{"bnrstark",0,(void*)bnrstark,10,"GDGp","bnrstark(bnr,{subgroup}): bnr being as output by bnrinit, finds a relative equation for the class field corresponding to the module in bnr and the given congruence subgroup (the trivial subgroup if omitted) using Stark's units. The ground field and the class field must be totally real."},
{"break",0,(void*)break0,1,"D1,L,","break({n=1}): interrupt execution of current instruction sequence, and exit from the n innermost enclosing loops."},
{"call",0,(void*)call0,1,"GG","call(f, A): A being a vector, evaluates f(A[1],...,A[#A])."},
{"ceil",0,(void*)gceil,3,"G","ceil(x): ceiling of x = smallest integer >= x."},
{"centerlift",0,(void*)centerlift0,3,"GDn","centerlift(x,{v}): centered lift of x. Same as lift except for intmod and padic components."},
{"characteristic",0,(void*)characteristic,3,"mG","characteristic(x): characteristic of the base ring over which x is defined."},
{"charconj",0,(void*)charconj0,5,"GG","charconj(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return the conjugate character."},
{"chardiv",0,(void*)chardiv0,5,"GGG","chardiv(cyc, a,b): given a finite abelian group (by its elementary divisors cyc) and two characters a and b, return the character a/b."},
{"chareval",0,(void*)chareval,5,"GGGDG","chareval(G, chi, x, {z}): given an abelian group structure affording a discrete logarithm method, e.g. G = znstar(N,1) or a bnr structure, let x be an element of G and let chi be a character of G. This function returns the value of chi at x, where the encoding depends on the optional argument z; if z is omitted, we fix a canonical o-th root of 1, zeta_o, where o is the character order and return the rational number c/o where chi(x) = (zeta_o)^c."},
{"chargalois",0,(void*)chargalois,5,"GDG","chargalois(cyc,{ORD}): let cyc represent a finite abelian group G by its elementary divisors cyc, return a list of representatives for the Galois orbits of characters of G. If ORD is present, select characters depending on their orders: if ORD is a t_INT, restrict to orders less than this bound; if ORD is a t_VEC or t_VECSMALL, restrict to orders in the list."},
{"charker",0,(void*)charker0,5,"GG","charker(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return its kernel."},
{"charmul",0,(void*)charmul0,5,"GGG","charmul(cyc, a,b): given a finite abelian group (by its elementary divisors cyc) and two characters a and b, return the product character ab."},
{"charorder",0,(void*)charorder0,5,"GG","charorder(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return the order of chi."},
{"charpoly",0,(void*)charpoly0,7,"GDnD5,L,","charpoly(A,{v='x},{flag=5}): det(v*Id-A)=characteristic polynomial of the matrix or polmod A. flag is optional and ignored unless A is a matrix; it may be set to 0 (Le Verrier), 1 (Lagrange interpolation), 2 (Hessenberg form), 3 (Berkowitz), 4 (modular) if A is integral, or 5 (default, choose best method). Algorithms 0 (Le Verrier) and 1 (Lagrange) assume that n! is invertible, where n is the dimension of the matrix."},
{"charpow",0,(void*)charpow0,5,"GGG","charpow(cyc, a,n): given a finite abelian group (by its elementary divisors cyc) a character a and an integer n return the character a^n."},
{"chinese",0,(void*)chinese,5,"GDG","chinese(x,{y}): x,y being both intmods (or polmods) computes z in the same residue classes as x and y."},
{"cmp",0,(void*)cmp_universal,2,"iGG","cmp(x,y): compare two arbitrary objects x and y (1 if x>y, 0 if x=y, -1 if x<y). The function is used to implement sets, and has no useful mathematical meaning."},
{"component",0,(void*)compo,3,"GL","component(x,n): the n'th component of the internal representation of x. For vectors or matrices, it is simpler to use x[]. For list objects such as nf, bnf, bnr or ell, it is much easier to use member functions starting with \".\"."},
{"concat",0,(void*)gconcat,7,"GDG","concat(x,{y}): concatenation of x and y, which can be scalars, vectors or matrices, or lists (in this last case, both x and y have to be lists). If y is omitted, x has to be a list or row vector and its elements are concatenated."},
{"conj",0,(void*)gconj,3,"G","conj(x): the algebraic conjugate of x."},
{"conjvec",0,(void*)conjvec,3,"Gp","conjvec(z): conjugate vector of the algebraic number z."},
{"content",0,(void*)content0,5,"GDG","content(x,{D}): gcd of all the components of x, when this makes sense."},
{"contfrac",0,(void*)contfrac0,5,"GDGD0,L,","contfrac(x,{b},{nmax}): continued fraction expansion of x (x rational,real or rational function). b and nmax are both optional, where b is the vector of numerators of the continued fraction, and nmax is a bound for the number of terms in the continued fraction expansion."},
{"contfraceval",0,(void*)contfraceval,9,"GGD-1,L,","contfraceval(CF,t,{lim=-1}): given a continued fraction CF from contfracinit, evaluate the first lim terms of the continued fraction at t (all terms if lim is negative or omitted)."},
{"contfracinit",0,(void*)contfracinit,9,"GD-1,L,","contfracinit(M,{lim = -1}): given M representing the power series S = sum_{n>=0} M[n+1]z^n, transform it into a continued fraction suitable for evaluation."},
{"contfracpnqn",0,(void*)contfracpnqn,5,"GD-1,L,","contfracpnqn(x, {n=-1}): [p_n,p_{n-1}; q_n,q_{n-1}] corresponding to the continued fraction x. If n >= 0 is present, returns all convergents from p_0/q_0 up to p_n/q_n."},
{"core",0,(void*)core0,5,"GD0,L,","core(n,{flag=0}): unique squarefree integer d dividing n such that n/d is a square. If (optional) flag is non-null, output the two-component row vector [d,f], where d is the unique squarefree integer dividing n such that n/d=f^2 is a square."},
{"coredisc",0,(void*)coredisc0,5,"GD0,L,","coredisc(n,{flag=0}): discriminant of the quadratic field Q(sqrt(n)). If (optional) flag is non-null, output a two-component row vector [d,f], where d is the discriminant of the quadratic field Q(sqrt(n)) and n=df^2. f may be a half integer."},
{"cos",0,(void*)gcos,8,"Gp","cos(x): cosine of x."},
{"cosh",0,(void*)gcosh,8,"Gp","cosh(x): hyperbolic cosine of x."},
{"cotan",0,(void*)gcotan,8,"Gp","cotan(x): cotangent of x."},
{"cotanh",0,(void*)gcotanh,8,"Gp","cotanh(x): hyperbolic cotangent of x."},
{"dbg_x",0,(void*)dbgGEN,1,"vGD-1,L,","dbg_x(A,{n}): print inner structure of A, complete if n is omitted, up to level n otherwise. Intended for debugging."},
{"default",0,(void*)default0,1,"DrDs","default({key},{val}): returns the current value of the default key. If val is present, set opt to val first. If no argument is given, print a list of all defaults as well as their values."},
{"denominator",0,(void*)denominator,3,"GDG","denominator(f,{D}): denominator of f."},
{"deriv",0,(void*)deriv,6,"GDn","deriv(x,{v}): derivative of x with respect to v, or to the main variable of x if v is omitted."},
{"derivnum",0,(void*)derivnum0,9,"V=GEDGp","derivnum(X=a,expr,{ind=1}): numerical derivation of expr with respect to X at X = a. The order of derivation is given by parameter 'ind'."},
{"diffop",0,(void*)diffop0,6,"GGGD1,L,","diffop(x,v,d,{n=1}): apply the differential operator D to x, where D is defined by D(v[i])=d[i], where v is a vector of variable names. D is 0 for variables outside of v unless they appear as modulus of a POLMOD. If the optional parameter n is given, return D^n(x) instead."},
{"digits",0,(void*)digits,3,"GDG","digits(x,{b=10}): gives the vector formed by the digits of x in base b (x and b integers)."},
{"dilog",0,(void*)dilog,8,"Gp","dilog(x): dilogarithm of x."},
{"dirdiv",0,(void*)dirdiv,5,"GG","dirdiv(x,y): division of the Dirichlet series x by the Dirichlet series y."},
{"direuler",0,(void*)direuler0,5,"V=GGEDG","direuler(p=a,b,expr,{c}): Dirichlet Euler product of expression expr from p=a to p=b, limited to b terms. Expr should be a polynomial or rational function in p and X, and X is understood to mean p^(-s). If c is present, output only the first c terms."},
{"dirmul",0,(void*)dirmul,5,"GG","dirmul(x,y): multiplication of the Dirichlet series x by the Dirichlet series y."},
{"dirzetak",0,(void*)dirzetak,10,"GG","dirzetak(nf,b): Dirichlet series of the Dedekind zeta function of the number field nf up to the bound b-1."},
{"divisors",0,(void*)divisors0,5,"GD0,L,","divisors(x,{flag=0}): gives a vector formed by the divisors of x in increasing order. If flag = 1, return pairs [d, factor(d)]."},
{"divisorslenstra",0,(void*)divisorslenstra,5,"GGG","divisorslenstra(N, r, s): finds all divisors d of N such that d = r (mod s). Assume that (r,s) = 1 and s^3 > N."},
{"divrem",0,(void*)divrem,2,"GGDn","divrem(x,y,{v}): euclidean division of x by y giving as a 2-dimensional column vector the quotient and the remainder, with respect to v (to main variable if v is omitted)."},
{"eint1",0,(void*)veceint1,8,"GDGp","eint1(x,{n}): exponential integral E1(x). If n is present and x > 0, computes the vector of the first n values of the exponential integral E1(n x)."},
{"ellL1",0,(void*)ellL1_bitprec,12,"GD0,L,b","ellL1(E, {r = 0}): returns the value at s=1 of the derivative of order r of the L-function of the elliptic curve E."},
{"elladd",0,(void*)elladd,12,"GGG","elladd(E,z1,z2): sum of the points z1 and z2 on elliptic curve E."},
{"ellak",0,(void*)akell,12,"GG","ellak(E,n): computes the n-th Fourier coefficient of the L-function of the elliptic curve E (assumes E is an integral model)."},
{"ellan",0,(void*)ellan,12,"GL","ellan(E,n): computes the first n Fourier coefficients of the L-function of the elliptic curve E defined over a number field (n<2^24 on a 32-bit machine)."},
{"ellanalyticrank",0,(void*)ellanalyticrank_bitprec,12,"GDGb","ellanalyticrank(E, {eps}): returns the order of vanishing at s=1 of the L-function of the elliptic curve E and the value of the first non-zero derivative. To determine this order, it is assumed that any value less than eps is zero. If no value of eps is given, 2^(-bitprecision/2) is used."},
{"ellap",0,(void*)ellap,12,"GDG","ellap(E,{p}): given an elliptic curve E defined over a finite field Fq, return the trace of Frobenius a_p = q+1-#E(Fq); for other fields of definition K, p must define a finite residue field, (p prime for K = Qp or Q; p a maximal ideal for K a number field), return the order of the (non-singular) reduction of E."},
{"ellbil",0,(void*)bilhell,12,"GGGp","ellbil(E,z1,z2): deprecated alias for ellheight(E,P,Q)."},
{"ellbsd",0,(void*)ellbsd,12,"Gp","ellbsd(E): E being an elliptic curve over a number field, returns a real number c such that the BSD conjecture predicts that lfun(E,1,r)/r! = c*R*S where r is the rank, R is the regulator and S is the cardinal of the Tate-Shafarevich group."},
{"ellcard",0,(void*)ellcard,12,"GDG","ellcard(E,{p}): given an elliptic curve E defined over a finite field Fq, return the order of the group E(Fq); for other fields of definition K, p must define a finite residue field, (p prime for K = Qp or Q; p a maximal ideal for K a number field), return the order of the (non-singular) reduction of E."},
{"ellchangecurve",0,(void*)ellchangecurve,12,"GG","ellchangecurve(E,v): change data on elliptic curve according to v=[u,r,s,t]."},
{"ellchangepoint",0,(void*)ellchangepoint,12,"GG","ellchangepoint(x,v): change data on point or vector of points x on an elliptic curve according to v=[u,r,s,t]."},
{"ellchangepointinv",0,(void*)ellchangepointinv,12,"GG","ellchangepointinv(x,v): change data on point or vector of points x on an elliptic curve according to v=[u,r,s,t], inverse of ellchangepoint."},
{"ellconvertname",0,(void*)ellconvertname,12,"G","ellconvertname(name): convert an elliptic curve name (as found in the elldata database) from a string to a triplet [conductor, isogeny class, index]. It will also convert a triplet back to a curve name."},
{"elldivpol",0,(void*)elldivpol,12,"GLDn","elldivpol(E,n,{v='x}): n-division polynomial f_n for the curve E in the variable v."},
{"elleisnum",0,(void*)elleisnum,12,"GLD0,L,p","elleisnum(w,k,{flag=0}): k being an even positive integer, computes the numerical value of the Eisenstein series of weight k at the lattice w, as given by ellperiods. When flag is non-zero and k=4 or 6, this gives the elliptic invariants g2 or g3 with the correct normalization."},
{"elleta",0,(void*)elleta,12,"Gp","elleta(w): w=[w1,w2], returns the vector [eta1,eta2] of quasi-periods attached to [w1,w2]."},
{"ellformaldifferential",0,(void*)ellformaldifferential,12,"GDPDn","ellformaldifferential(E, {n=seriesprecision}, {t = 'x}) : E elliptic curve, n integer. Returns n terms of the power series [f, g] such that omega = dx/(2y+a_1x+a_3) = f(t) dt and eta = x(t) * omega = g(t) dt in the local parameter t=-x/y."},
{"ellformalexp",0,(void*)ellformalexp,12,"GDPDn","ellformalexp(E, {n = seriesprecision}, {z = 'x}) : E elliptic curve, returns n terms of the formal elliptic exponential on E as a series in z."},
{"ellformallog",0,(void*)ellformallog,12,"GDPDn","ellformallog(E, {n = seriesprecision}, {v = 'x}): E elliptic curve, returns n terms of the elliptic logarithm as a series of t =-x/y."},
{"ellformalpoint",0,(void*)ellformalpoint,12,"GDPDn","ellformalpoint(E, {n = seriesprecision}, {v = 'x}): E elliptic curve, n integer; return the coordinates [x(t), y(t)] on the elliptic curve as a formal expansion in the formal parameter t = -x/y."},
{"ellformalw",0,(void*)ellformalw,12,"GDPDn","ellformalw(E, {n = seriesprecision}, {t = 'x}): E elliptic curve, n integer; returns n terms of the formal expansion of w = -1/y in the formal parameter t = -x/y."},
{"ellfromeqn",0,(void*)ellfromeqn,12,"G","ellfromeqn(P): given a genus 1 plane curve, defined by the affine equation f(x,y) = 0, return the coefficients [a1,a2,a3,a4,a6] of a Weierstrass equation for its Jacobian. This allows to recover a Weierstrass model for an elliptic curve given by a general plane cubic or by a binary quartic or biquadratic model."},
{"ellfromj",0,(void*)ellfromj,12,"G","ellfromj(j): returns the coefficients [a1,a2,a3,a4,a6] of a fixed elliptic curve with j-invariant j."},
{"ellgenerators",0,(void*)ellgenerators,12,"G","ellgenerators(E): if E is an elliptic curve over the rationals, return the generators of the Mordell-Weil group attached to the curve. This relies on the curve being referenced in the elldata database. If E is an elliptic curve over a finite field Fq as output by ellinit(), return a minimal set of generators for the group E(Fq)."},
{"ellglobalred",0,(void*)ellglobalred,12,"G","ellglobalred(E): E being an elliptic curve over a number field, returns [N, v, c, faN, L], where N is the conductor of E, c is the product of the local Tamagawa numbers c_p, faN is the factorization of N and L[i] is elllocalred(E, faN[i,1]); v is an obsolete field."},
{"ellgroup",0,(void*)ellgroup0,12,"GDGD0,L,","ellgroup(E,{p},{flag}): given an elliptic curve E defined over a finite field Fq, return the structure of the group E(Fq); for other fields of definition K, p must define a finite residue field (p prime for K = Qp or Q; p a maximal ideal for K a number field) and we return the structure of the (non-singular) reduction of E. If flag is 1, return also generators, the curve equation must be minimal at p."},
{"ellheegner",0,(void*)ellheegner,12,"G","ellheegner(E): return a rational non-torsion point on the elliptic curve E assumed to be of rank 1."},
{"ellheight",0,(void*)ellheight0,12,"GGDGp","ellheight(E,P,{Q}): canonical height of point P on elliptic curve E, resp. the value of the attached bilinear form at (P,Q)."},
{"ellheightmatrix",0,(void*)ellheightmatrix,12,"GGp","ellheightmatrix(E,x): gives the height matrix for vector of points x on elliptic curve E."},
{"ellidentify",0,(void*)ellidentify,12,"G","ellidentify(E): look up the elliptic curve E in the elldata database and return [[N, M, ...], C] where N is the name of the curve in Cremona's database, M the minimal model and C the coordinates change (see ellchangecurve)."},
{"ellinit",0,(void*)ellinit,12,"GDGp","ellinit(x,{D=1}): let x be a vector [a1,a2,a3,a4,a6], or [a4,a6] if a1=a2=a3=0, defining the curve Y^2 + a1.XY + a3.Y = X^3 + a2.X^2 + a4.X + a6; x can also be a string, in which case the curve with matching name is retrieved from the elldata database, if available. This function initializes an elliptic curve over the domain D (inferred from coefficients if omitted)."},
{"ellintegralmodel",0,(void*)ellintegralmodel,12,"GD&","ellintegralmodel(E,{&v}): given an elliptic curve E defined over a number field or Qp, returns an integral model. If v is present, sets the variable v to the corresponding change of variable."},
{"ellisdivisible",0,(void*)ellisdivisible,12,"lGGGD&","ellisdivisible(E,P,n,{&Q}): given E/K and P in E(K), checks whether P = [n]R for some R in E(K) and sets Q to one such R if so; the integer n >= 0 may be given as ellxn(E,n)."},
{"ellisogeny",0,(void*)ellisogeny,12,"GGD0,L,DnDn","ellisogeny(E, G, {only_image = 0}, {x = 'x}, {y = 'y}): compute the image and isogeny corresponding to the quotient of E by the subgroup G."},
{"ellisogenyapply",0,(void*)ellisogenyapply,12,"GG","ellisogenyapply(f, g): given an isogeny f and g either a point P (in the domain of f) or an isogeny, apply f to g: return the image of P under f or the composite isogeny f o g."},
{"ellisomat",0,(void*)ellisomat,12,"GD0,L,D0,L,","ellisomat(E, {p=0}, {fl=0}): E being an elliptic curve over a number field, return a list of representatives of the isomorphism classes of elliptic curves isogenous to E, with the corresponding isogenies from E and their dual, and the matrix of the degrees of the isogenies between the curves. If the flag fl is 1, the isogenies are not computed, which saves time. If p is set, it must be a prime number: in this case only isogenies of degree a power of p are considered. Currently  CM curves over a number field are not fully supported."},
{"ellisoncurve",0,(void*)ellisoncurve,12,"GG","ellisoncurve(E,z): true(1) if z is on elliptic curve E, false(0) if not."},
{"ellisotree",0,(void*)ellisotree,12,"G","ellisotree(E): E being an elliptic curve over Q or a set of isogenous rational curves as given by ellisomat, return minimal models of the isomorphism classes of elliptic curves isogenous to E (or in the set) and the oriented graph of isogenies of prime degree (adjacency matrix)."},
{"ellissupersingular",0,(void*)ellissupersingular,12,"iGDG","ellissupersingular(E,{p}): return 1 if the elliptic curve E, defined over a number field or a finite field, is supersingular at p, and 0 otherwise."},
{"ellj",0,(void*)jell,12,"Gp","ellj(x): elliptic j invariant of x."},
{"elllocalred",0,(void*)elllocalred,12,"GDG","elllocalred(E,{p}): E being an elliptic curve, returns [f,kod,[u,r,s,t],c], where f is the conductor's exponent, kod is the Kodaira type for E at p, [u,r,s,t] is the change of variable needed to make E minimal at p, and c is the local Tamagawa number c_p."},
{"elllog",0,(void*)elllog,12,"GGGDG","elllog(E,P,G,{o}): return the discrete logarithm of the point P of the elliptic curve E in base G. If present, o represents the order of G. If not present, assume that G generates the curve."},
{"elllseries",0,(void*)elllseries,12,"GGDGp","elllseries(E,s,{A=1}): L-series at s of the elliptic curve E, where A a cut-off point close to 1."},
{"ellminimaldisc",0,(void*)ellminimaldisc,12,"G","ellminimaldisc(E): E being an elliptic curve defined over a number  field output by ellinit, return the minimal discriminant ideal of E."},
{"ellminimalmodel",0,(void*)ellminimalmodel,12,"GD&","ellminimalmodel(E,{&v}): determines whether the elliptic curve E defined over a number field admits a global minimal model. If so return it and sets v to the corresponding change of variable. Else return the (non-principal) Weierstrass class of E."},
{"ellminimaltwist",0,(void*)ellminimaltwist0,12,"GD0,L,","ellminimaltwist(E, {flag=0}): E being an elliptic curve defined over Q, return a discriminant D such that the twist of E by D is minimal among all possible quadratic twists, i.e., if flag=0, its minimal model has minimal discriminant, or if flag=1, it has minimal conductor."},
{"ellmoddegree",0,(void*)ellmoddegree,12,"G","ellmoddegree(e): e being an elliptic curve defined over Q output by ellinit, compute the modular degree of e divided by the square of the Manin constant."},
{"ellmodulareqn",0,(void*)ellmodulareqn,12,"LDnDn","ellmodulareqn(N,{x},{y}): given a prime N < 500, return a vector [P, t] where P(x,y) is a modular equation of level N. This requires the package seadata. The equation is either of canonical type (t=0) or of Atkin type (t=1)."},
{"ellmul",0,(void*)ellmul,12,"GGG","ellmul(E,z,n): n times the point z on elliptic curve E (n in Z)."},
{"ellneg",0,(void*)ellneg,12,"GG","ellneg(E,z): opposite of the point z on elliptic curve E."},
{"ellnonsingularmultiple",0,(void*)ellnonsingularmultiple,12,"GG","ellnonsingularmultiple(E,P): given E/Q and P in E(Q), returns the pair [R,n] where n is the least positive integer such that R = [n]P has everywhere good reduction. More precisely, its image in a minimal model is everywhere non-singular."},
{"ellorder",0,(void*)ellorder,12,"GGDG","ellorder(E,z,{o}): order of the point z on the elliptic curve E over a number field or a finite field, 0 if non-torsion. The parameter o, if present, represents a non-zero multiple of the order of z."},
{"ellordinate",0,(void*)ellordinate,12,"GGp","ellordinate(E,x): y-coordinates corresponding to x-ordinate x on elliptic curve E."},
{"ellpadicL",0,(void*)ellpadicL,12,"GGLDGD0,L,DG","ellpadicL(E, p, n, {s = 0}, {r = 0}, {D = 1}): returns the value on a character of Z_p^* represented by an integer s or a vector [s1,s2] of the derivative of order r of the p-adic L-function of the elliptic curve E (twisted by D, if present)."},
{"ellpadicbsd",0,(void*)ellpadicbsd,12,"GGLDG","ellpadicbsd(E, p, n, {D = 1}): returns [r,Lp] where r is the (conjectural) analytic rank of the p-adic L-function attached to the quadratic twist E_D and Lp is (conjecturally) equal to the product of the p-adic regulator and the cardinal of the Tate-Shafarevich group."},
{"ellpadicfrobenius",0,(void*)ellpadicfrobenius,12,"GLL","ellpadicfrobenius(E,p,n): matrix of the Frobenius at p>2 in the standard basis of H^1_dR(E) to absolute p-adic precision p^n."},
{"ellpadicheight",0,(void*)ellpadicheight0,12,"GGLGDG","ellpadicheight(E,p,n, P,{Q}): E elliptic curve/Q, P in E(Q), p prime, n an integer; returns the cyclotomic p-adic heights of P. Resp. the value of the attached bilinear form at (P,Q)."},
{"ellpadicheightmatrix",0,(void*)ellpadicheightmatrix,12,"GGLG","ellpadicheightmatrix(E,p,n,Q): gives the height-pairing matrix for vector of points Q on elliptic curve E."},
{"ellpadiclog",0,(void*)ellpadiclog,12,"GGLG","ellpadiclog(E,p,n,P): returns the logarithm of P (in the kernel of reduction) to relative p-adic precision p^n."},
{"ellpadicregulator",0,(void*)ellpadicregulator,12,"GGLG","ellpadicregulator(E,p,n,S): E elliptic curve/Q, S a vector of points in E(Q), p prime, n an integer; returns the p-adic cyclotomic regulator of the points of S at precision p^n."},
{"ellpadics2",0,(void*)ellpadics2,12,"GGL","ellpadics2(E,p,n): returns s2 to absolute p-adic precision p^n."},
{"ellperiods",0,(void*)ellperiods,12,"GD0,L,p","ellperiods(w, {flag = 0}): w describes a complex period lattice ([w1,w2] or an ellinit structure). Returns normalized periods [W1,W2] generating the same lattice such that tau := W1/W2 satisfies Im(tau) > 0 and lies in the standard fundamental domain for SL2. If flag is 1, the return value is [[W1,W2], [e1,e2]], where e1, e2 are the quasi-periods attached to [W1,W2], satisfying e2 W1 - e1 W2 = 2*I*Pi."},
{"ellpointtoz",0,(void*)zell,12,"GGp","ellpointtoz(E,P): lattice point z corresponding to the point P on the elliptic curve E."},
{"ellpow",0,(void*)ellmul,12,"GGG","ellpow(E,z,n): deprecated alias for ellmul."},
{"ellratpoints",0,(void*)ellratpoints,12,"GGD0,L,","ellratpoints(E,h,{flag=0}): E being an integral model of an elliptic curve, return a vector containing the affine rational points on the curve of naive height less than h. If fl=1, stop as soon as a point is found."},
{"ellrootno",0,(void*)ellrootno,12,"lGDG","ellrootno(E,{p}): root number for the L-function of the elliptic curve E/Q at a prime p (including 0, for the infinite place); global root number if p is omitted. If p is omitted, the curve can also be defined over a number field."},
{"ellsea",0,(void*)ellsea,12,"GD0,L,","ellsea(E,{tors=0}): computes the order of the group E(Fq) for the elliptic curve E, defined over a finite field, using SEA algorithm, with early abort for curves (or their quadratic twist) with non-prime order."},
{"ellsearch",0,(void*)ellsearch,12,"G","ellsearch(N): returns all curves in the elldata database matching constraint N:  given name (N = \"11a1\" or [11,0,1]), given isogeny class (N = \"11a\" or [11,0]), or given conductor (N = 11, \"11\", or [11])."},
{"ellsigma",0,(void*)ellsigma,12,"GDGD0,L,p","ellsigma(L,{z='x},{flag=0}): computes the value at z of the Weierstrass sigma function attached to the lattice L, as given by ellperiods(,1). If flag = 1, returns an arbitrary determination of the logarithm of sigma."},
{"ellsub",0,(void*)ellsub,12,"GGG","ellsub(E,z1,z2): difference of the points z1 and z2 on elliptic curve E."},
{"elltamagawa",0,(void*)elltamagawa,12,"G","elltamagawa(E): E being an elliptic curve over a number field, returns the global Tamagawa number of the curve."},
{"elltaniyama",0,(void*)elltaniyama,12,"GDP","elltaniyama(E, {d = seriesprecision}): modular parametrization of elliptic curve E/Q."},
{"elltatepairing",0,(void*)elltatepairing,12,"GGGG","elltatepairing(E, P, Q, m): computes the Tate pairing of the two points P and Q on the elliptic curve E. The point P must be of m-torsion."},
{"elltors",0,(void*)elltors,12,"G","elltors(E): torsion subgroup of elliptic curve E: order, structure, generators."},
{"elltwist",0,(void*)elltwist,12,"GDG","elltwist(E,{P}): returns the coefficients [a1,a2,a3,a4,a6] of the twist of the elliptic curve E by the quadratic extension defined by P (when P is a polynomial of degree 2) or quadpoly(P) (when P is an integer). If E is defined over a finite field, then P can be omitted."},
{"ellweilcurve",0,(void*)ellweilcurve,12,"GD&","ellweilcurve(E, {&ms}): let E be an elliptic curve over Q given by ellinit or a rational isogeny class given by ellisomat. Return a list of isomorphism classes of elliptic curves isogenous to E as given by ellisomat and the list of the Smith invariants of the lattice associated to E in H^1(E,Q) in the lattice associated to the modular form. If ms is present, it contains the output of msfromell(Emin,0) where Emin is the list of minimal models attached to the curves in the isogeny class."},
{"ellweilpairing",0,(void*)ellweilpairing,12,"GGGG","ellweilpairing(E, P, Q, m): computes the Weil pairing of the two points of m-torsion P and Q on the elliptic curve E."},
{"ellwp",0,(void*)ellwp0,12,"GDGD0,L,p","ellwp(w,{z='x},{flag=0}): computes the value at z of the Weierstrass P function attached to the lattice w, as given by ellperiods. Optional flag means 0 (default), compute only P(z), 1 compute [P(z),P'(z)]."},
{"ellxn",0,(void*)ellxn,12,"GLDn","ellxn(E,n,{v='x}): return the polynomials [phi_n, (psi_n)^2] in the variable v, where x([n]P) = phi_n/(psi_n)^2."},
{"ellzeta",0,(void*)ellzeta,12,"GDGp","ellzeta(w,{z='x}): computes the value at z of the Weierstrass Zeta function attached to the lattice w, as given by ellperiods(,1)."},
{"ellztopoint",0,(void*)pointell,12,"GGp","ellztopoint(E,z): inverse of ellpointtoz. Returns the coordinates of point P on the curve E corresponding to a complex or p-adic z."},
{"erfc",0,(void*)gerfc,8,"Gp","erfc(x): complementary error function."},
{"errname",0,(void*)errname,1,"G","errname(E): returns the type of the error message E."},
{"error",0,(void*)error0,1,"vs*","error({str}*): abort script with error message str."},
{"eta",0,(void*)eta0,8,"GD0,L,p","eta(z,{flag=0}): if flag=0, returns prod(n=1,oo, 1-q^n), where q = exp(2 i Pi z) if z is a complex scalar (belonging to the upper half plane); q = z if z is a p-adic number or can be converted to a power series. If flag is non-zero, the function only applies to complex scalars and returns the true eta function, with the factor q^(1/24) included."},
{"eulerphi",0,(void*)eulerphi,5,"G","eulerphi(x): Euler's totient function of x."},
{"eval",0,(void*)geval_gp,6,"GC","eval(x): evaluation of x, replacing variables by their value."},
{"exp",0,(void*)gexp,8,"Gp","exp(x): exponential of x."},
{"expm1",0,(void*)gexpm1,8,"Gp","expm1(x): exp(x)-1."},
{"exponent",0,(void*)gpexponent,3,"G","exponent(x): binary exponent of x"},
{"extern",0,(void*)gpextern,1,"s","extern(str): execute shell command str, and feeds the result to GP (as if loading from file)."},
{"externstr",0,(void*)externstr,1,"s","externstr(str): execute shell command str, and returns the result as a vector of GP strings, one component per output line."},
{"factor",0,(void*)factor0,5,"GDG","factor(x,{D}): factorization of x over domain D. If x and D are both integers, return partial factorization, using primes < D."},
{"factorback",0,(void*)factorback2,5,"GDG","factorback(f,{e}): given a factorization f, gives the factored object back. If e is present, f has to be a vector of the same length, and we return the product of the f[i]^e[i]."},
{"factorcantor",0,(void*)factmod,5,"GG","factorcantor(x,p): this function is obsolete, use factormod."},
{"factorff",0,(void*)factorff,5,"GDGDG","factorff(x,{p},{a}): obsolete, use factormod."},
{"factorial",0,(void*)mpfactr,5,"Lp","factorial(x): factorial of x, the result being given as a real number."},
{"factorint",0,(void*)factorint,5,"GD0,L,","factorint(x,{flag=0}): factor the integer x. flag is optional, whose binary digits mean 1: avoid MPQS, 2: avoid first-stage ECM (may fall back on it later), 4: avoid Pollard-Brent Rho and Shanks SQUFOF, 8: skip final ECM (huge composites will be declared prime)."},
{"factormod",0,(void*)factormod0,5,"GDGD0,L,","factormod(f,{D},{flag=0}): factors the polynomial f over the finite field defined by the domain D; flag is optional, and can be 0: default or 1: only the degrees of the irreducible factors are given."},
{"factormodDDF",0,(void*)factormodDDF,5,"GDG","factormodDDF(f,{D}): distinct-degree factorization of the squarefree polynomial f over the finite field defined by the domain D."},
{"factormodSQF",0,(void*)factormodSQF,5,"GDG","factormodSQF(f,{D}): squarefree factorization of the polynomial f over the finite field defined by the domain D."},
{"factornf",0,(void*)polfnf,10,"GG","factornf(x,t): this function is obsolete, use nffactor."},
{"factorpadic",0,(void*)factorpadic,6,"GGL","factorpadic(pol,p,r): p-adic factorization of the polynomial pol to precision r."},
{"ffcompomap",0,(void*)ffcompomap,5,"GG","ffcompomap(f, g): Let k, l, m be three finite fields and f a (partial) map from l to m and g a partial map from k to l, return the (partial) map f o g from k to m."},
{"ffembed",0,(void*)ffembed,5,"GG","ffembed(a, b): given two elements a and b in finite fields, return a map embedding the definition field of a to the definition field of b."},
{"ffextend",0,(void*)ffextend,5,"GGDn","ffextend(a, P, {v}): extend the field K of definition of a by a root of the polynomial P, assumed to be irreducible over K.  Return [r, m] where r is a root of P in the extension field L and m is a map from K to L, see \\kbd{ffmap}. If v is given, the variable name is used to display the generator of L, else the name of the variable of P is used."},
{"fffrobenius",0,(void*)fffrobenius,5,"GD1,L,","fffrobenius(m,{n=1}): return the n-th power of the Frobenius map over the field of definition of m."},
{"ffgen",0,(void*)ffgen,5,"GDn","ffgen(k,{v = 'x}): return a generator of the finite field k (not necessarily a generator of its multiplicative group) as a t_FFELT. k can be given by its order q, the pair [p,f] with q=p^f, by an irreducible polynomial with t_INTMOD coefficients, or by a finite field element. If v is given, the variable name is used to display g, else the variable of the polynomial or finite field element, or x if only the order was given."},
{"ffinit",0,(void*)ffinit,5,"GLDn","ffinit(p,n,{v='x}): monic irreducible polynomial of degree n over F_p[v]."},
{"ffinvmap",0,(void*)ffinvmap,5,"G","ffinvmap(m): given a map m between finite fields, return a partial map that return the pre-images by the map m."},
{"fflog",0,(void*)fflog,5,"GGDG","fflog(x,g,{o}): return the discrete logarithm of the finite field element x in base g. If present, o must represents the multiplicative order of g. If no o is given, assume that g is a primitive root."},
{"ffmap",0,(void*)ffmap,5,"GG","ffmap(m, x): given a (partial) map m between two finite fields, return the image of x by m. The function is applied recursively to the component of vectors, matrices and polynomials. If m is a partial map that is not defined at x, return []"},
{"ffnbirred",0,(void*)ffnbirred0,5,"GLD0,L,","ffnbirred(q,n,{fl=0}): number of monic irreducible polynomials over F_q, of degree n (fl=0, default) or at most n (fl=1)."},
{"fforder",0,(void*)fforder,5,"GDG","fforder(x,{o}): multiplicative order of the finite field element x. Optional o represents a multiple of the order of the element."},
{"ffprimroot",0,(void*)ffprimroot,5,"GD&","ffprimroot(x, {&o}): return a primitive root of the multiplicative group of the definition field of the finite field element x (not necessarily the same as the field generated by x). If present, o is set to [ord, fa], where ord is the order of the group, and fa its factorization (useful in fflog and fforder)."},
{"fibonacci",0,(void*)fibo,4,"L","fibonacci(x): fibonacci number of index x (x C-integer)."},
{"fileclose",0,(void*)gp_fileclose,1,"vL","fileclose(n): close the file descriptor n."},
{"fileextern",0,(void*)gp_fileextern,1,"ls","fileextern(str): execute shell command str and returns a file descriptor attached to the command output as if it were read from a file."},
{"fileflush",0,(void*)gp_fileflush0,1,"vDG","fileflush({n}): flush the file descriptor n (all descriptors to output streams if n is omitted)."},
{"fileopen",0,(void*)gp_fileopen,1,"lsD\"r\",s,","fileopen(path, mode): open the file pointed to by 'path' and return a file descriptor which can be used with other file functions. The mode is \"r\" (default, read), \"w\" (write, truncate), \"a\" (write, append)."},
{"fileread",0,(void*)gp_fileread,1,"L","fileread(n): read a logical line from the file attached to the descriptor n, opened for reading with fileopen. Return 0 at end of file."},
{"filereadstr",0,(void*)gp_filereadstr,1,"L","filereadstr(n): read a raw line from the file attached to the descriptor n, opened for reading with fileopen. Discard the terminating newline.  Return 0 at end of file."},
{"filewrite",0,(void*)gp_filewrite,1,"vLs","filewrite(n, s): write the string s to file attached to descriptor n, ending with a newline. The file must have been opened with fileopen in \"w\" or \"a\" mode."},
{"filewrite1",0,(void*)gp_filewrite1,1,"vLs","filewrite1(n, s): write the string s to file number n without ending with newline."},
{"floor",0,(void*)gfloor,3,"G","floor(x): floor of x = largest integer <= x."},
{"fold",0,(void*)fold0,1,"GG","fold(f, A): return f(...f(f(A[1],A[2]),A[3]),...,A[#A])."},
{"for",0,(void*)forpari,1,"vV=GGI","for(X=a,b,seq): the sequence is evaluated, X going from a up to b. If b is set to +oo, the loop will not stop."},
{"forcomposite",0,(void*)forcomposite,1,"vV=GDGI","forcomposite(n=a,{b},seq): the sequence is evaluated, n running over the composite numbers between a and b. Omitting b runs through composites >= a."},
{"fordiv",0,(void*)fordiv,1,"vGVI","fordiv(n,X,seq): the sequence is evaluated, X running over the divisors of n."},
{"fordivfactored",0,(void*)fordivfactored,1,"vGVI","fordivfactored(n,X,seq): the sequence is evaluated, X running over the [d, factor(d)], d a divisor of n."},
{"forell",0,(void*)forell0,1,"vVLLID0,L,","forell(E,a,b,seq,{flag=0}): execute seq for each elliptic curves E of conductor between a and b in the elldata database. If flag is non-zero, select only the first curve in each isogeny class."},
{"forfactored",0,(void*)forfactored,1,"vV=GGI","forfactored(N=a,b,seq): the sequence is evaluated, N is of the form [n, factor(n)], n going from a up to b."},
{"forpart",0,(void*)forpart0,1,"vV=GIDGDG","forpart(X=k,seq,{a=k},{n=k}): evaluate seq where the Vecsmall X goes over the partitions of k. Optional parameter n (n=nmax or n=[nmin,nmax]) restricts the length of the partition. Optional parameter a (a=amax or a=[amin,amax]) restricts the range of the parts. Zeros are removed unless one sets amin=0 to get X of fixed length nmax (=k by default)."},
{"forperm",0,(void*)forperm0,1,"vGVI","forperm(a,p,seq): the sequence is evaluated, p going through permutations of a."},
{"forprime",0,(void*)forprime,1,"vV=GDGI","forprime(p=a,{b},seq): the sequence is evaluated, p running over the primes between a and b. Omitting b runs through primes >= a."},
{"forprimestep",0,(void*)forprimestep,1,"vV=GDGGI","forprimestep(p=a,b,q,seq): the sequence is evaluated, p running over the primes in an arithmetic progression of the form a + k*q and less than b."},
{"forqfvec",0,(void*)forqfvec0,7,"vVGDGI","forqfvec(v,q,b,expr): q being a square and symmetric integral matrix representing an positive definite quadratic form, evaluate expr for all vectors v such that q(v)<=b."},
{"forsquarefree",0,(void*)forsquarefree,1,"vV=GGI","forsquarefree(N=a,b,seq): the sequence is evaluated, N is of the form [n, factor(n)], n going through squarefree integers from a up to b; one must have a*b >= 0."},
{"forstep",0,(void*)forstep,1,"vV=GGGI","forstep(X=a,b,s,seq): the sequence is evaluated, X going from a to b in steps of s (can be a vector of steps). If b is set to +oo the loop will not stop."},
{"forsubgroup",0,(void*)forsubgroup0,1,"vV=GDGI","forsubgroup(H=G,{bound},seq): execute seq for each subgroup H of the abelian group G, whose index is bounded by bound if not omitted. H is given as a left divisor of G in HNF form."},
{"forsubset",0,(void*)forsubset0,1,"vGVI","forsubset(nk, s, seq): if nk is an integer n, the sequence is evaluated,  s going through all subsets of {1, 2, ..., n}; if nk is a pair [n,k]  of integers s goes through k-subsets of {1, 2, ..., n}.  The order is lexicographic among subsets of the same size and smaller  subsets come first."},
{"forvec",0,(void*)forvec,1,"vV=GID0,L,","forvec(X=v,seq,{flag=0}): v being a vector of two-component vectors of length n, the sequence is evaluated with X[i] going from v[i][1] to v[i][2] for i=n,..,1 if flag is zero or omitted. If flag = 1 (resp. flag = 2), restrict to increasing (resp. strictly increasing) sequences."},
{"frac",0,(void*)gfrac,3,"G","frac(x): fractional part of x = x-floor(x)."},
{"fromdigits",0,(void*)fromdigits,3,"GDG","fromdigits(x,{b=10}): gives the integer formed by the elements of x seen as the digits of a number in base b."},
{"galoischardet",0,(void*)galoischardet,10,"GGD1,L,","galoischardet(gal, chi, {o=1}): return the determinant character of the character chi."},
{"galoischarpoly",0,(void*)galoischarpoly,10,"GGD1,L,","galoischarpoly(gal, chi, {o=1}): return the list of characteristic polynomials of the representation attached to the character chi."},
{"galoischartable",0,(void*)galoischartable,10,"G","galoischartable(gal): return the character table of the underlying group of gal."},
{"galoisconjclasses",0,(void*)galoisconjclasses,10,"G","galoisconjclasses(gal): gal being output by galoisinit, return the list of conjugacy classes."},
{"galoisexport",0,(void*)galoisexport,10,"GD0,L,","galoisexport(gal,{flag}): gal being a Galois group as output by galoisinit, output a string representing the underlying permutation group in GAP notation (default) or Magma notation (flag = 1)."},
{"galoisfixedfield",0,(void*)galoisfixedfield,10,"GGD0,L,Dn","galoisfixedfield(gal,perm,{flag},{v=y}): gal being a Galois group as output by galoisinit and perm a subgroup, an element of gal.group or a vector of such elements, return [P,x] such that P is a polynomial defining the fixed field of gal[1] by the subgroup generated by perm, and x is a root of P in gal expressed as a polmod in gal.pol. If flag is 1 return only P. If flag is 2 return [P,x,F] where F is the factorization of gal.pol over the field defined by P, where the variable v stands for a root of P."},
{"galoisgetgroup",0,(void*)galoisgetgroup,10,"LD0,L,","galoisgetgroup(a,{b}): query the galpol package for a group of order a with index b in the GAP4 Small Group library. If b is omitted, return the number of isomorphism classes of groups of order a."},
{"galoisgetname",0,(void*)galoisgetname,10,"LL","galoisgetname(a,b): query the galpol package for a string describing the group of order a with index b in the GAP4 Small Group library."},
{"galoisgetpol",0,(void*)galoisgetpol,10,"LD0,L,D1,L,","galoisgetpol(a,{b},{s}): query the galpol package for a polynomial with Galois group isomorphic to GAP4(a,b), totally real if s=1 (default) and totally complex if s=2.  The output is a vector [pol, den] where pol is the polynomial and den is the common denominator of the conjugates expressed as a polynomial in a root of pol. If b and s are omitted, return the number of isomorphism classes of groups of order a."},
{"galoisidentify",0,(void*)galoisidentify,10,"G","galoisidentify(gal): gal being a Galois group as output by galoisinit, output the isomorphism class of the underlying abstract group as a two-components vector [o,i], where o is the group order, and i is the group index in the GAP4 small group library."},
{"galoisinit",0,(void*)galoisinit,10,"GDG","galoisinit(pol,{den}): pol being a polynomial or a number field as output by nfinit defining a Galois extension of Q, compute the Galois group and all necessary information for computing fixed fields. den is optional and has the same meaning as in nfgaloisconj(,4)(see manual)."},
{"galoisisabelian",0,(void*)galoisisabelian,10,"GD0,L,","galoisisabelian(gal,{flag=0}): gal being as output by galoisinit, return 0 if gal is not abelian, the HNF matrix of gal over gal.gen if flag=0, 1 if flag is 1, and the SNF of gal is flag=2."},
{"galoisisnormal",0,(void*)galoisisnormal,10,"lGG","galoisisnormal(gal,subgrp): gal being as output by galoisinit, and subgrp a subgroup of gal as output by galoissubgroups, return 1 if subgrp is a normal subgroup of gal, else return 0."},
{"galoispermtopol",0,(void*)galoispermtopol,10,"GG","galoispermtopol(gal,perm): gal being a Galois group as output by galoisinit and perm a element of gal.group, return the polynomial defining the corresponding Galois automorphism."},
{"galoissubcyclo",0,(void*)galoissubcyclo,10,"GDGD0,L,Dn","galoissubcyclo(N,H,{fl=0},{v}): compute a polynomial (in variable v) defining the subfield of Q(zeta_n) fixed by the subgroup H of (Z/nZ)*. N can be an integer n, znstar(n) or bnrinit(bnfinit(y),[n,[1]]). H can be given by a generator, a set of generator given by a vector or a HNF matrix (see manual). If flag is 1, output only the conductor of the abelian extension. If flag is 2 output [pol,f] where pol is the polynomial and f the conductor."},
{"galoissubfields",0,(void*)galoissubfields,10,"GD0,L,Dn","galoissubfields(G,{flag=0},{v}): output all the subfields of G. flag has the same meaning as for galoisfixedfield."},
{"galoissubgroups",0,(void*)galoissubgroups,10,"G","galoissubgroups(G): output all the subgroups of G."},
{"gamma",0,(void*)ggamma,8,"Gp","gamma(s): gamma function at s, a complex or p-adic number, or a series."},
{"gammah",0,(void*)ggammah,8,"Gp","gammah(x): gamma of x+1/2 (x integer)."},
{"gammamellininv",0,(void*)gammamellininv,8,"GGD0,L,b","gammamellininv(G,t,{m=0}): returns G(t), where G is as output by gammamellininvinit. The alternative syntax gammamellininv(A,t,m) is also available."},
{"gammamellininvasymp",0,(void*)gammamellininvasymp,8,"GDPD0,L,","gammamellininvasymp(A,n,{m=0}): return the first n terms of the asymptotic expansion at infinity of the m-th derivative K^m(t) of the inverse Mellin transform of the function f(s)=Gamma_R(s+a_1)*...*Gamma_R(s+a_d), where Vga is the vector [a_1,...,a_d] and Gamma_R(s)=Pi^(-s/2)*gamma(s/2). The result is a vector [M[1]...M[n]] with M[1]=1, such that K^m(t) = \\sqrt{2^{d+1}/d}t^{a+m(2/d-1)}e^{-d pi t^{2/d}}\\sum_{n\\ge0}M[n+1] (pi t^{2n/d})^{-n}, with a = (1-d+sum_ja_j)/d."},
{"gammamellininvinit",0,(void*)gammamellininvinit,8,"GD0,L,b","gammamellininvinit(A,{m=0}): initialize data for the computation by gammamellininv() of the m-th derivative of the inverse Mellin transform of the function f(s) = Gamma_R(s+a1)*...*Gamma_R(s+ad), where A is the vector [a1,...,ad] and Gamma_R(s) = Pi^(-s/2)*gamma(s/2)."},
{"gcd",0,(void*)ggcd0,5,"GDG","gcd(x,{y}): greatest common divisor of x and y."},
{"gcdext",0,(void*)gcdext0,5,"GG","gcdext(x,y): returns [u,v,d] such that d=gcd(x,y) and u*x+v*y=d."},
{"genus2red",0,(void*)genus2red,12,"GDG","genus2red(PQ,{p}): let PQ be a polynomial P, resp. a vector [P,Q] of polynomials, with rational coefficients.  Determines the reduction at p > 2 of the (proper, smooth) hyperelliptic curve C/Q of genus 2 defined by y^2 = P, resp. y^2 + Q*y = P. More precisely, determines the special fiber X_p of the minimal regular model X of C over Z."},
{"getabstime",0,(void*)getabstime,1,"l","getabstime(): milliseconds of CPU time since startup."},
{"getcache",0,(void*)getcache,14,"","getcache(): returns information about various auto-growing caches. For each ressource, we report its name, its size, the number of cache misses (since the last extension) and the largest cache miss."},
{"getenv",0,(void*)gp_getenv,1,"s","getenv(s): value of the environment variable s, 0 if it is not defined."},
{"getheap",0,(void*)getheap,1,"","getheap(): 2-component vector giving the current number of objects in the heap and the space they occupy (in long words)."},
{"getrand",0,(void*)getrand,1,"","getrand(): current value of random number seed."},
{"getstack",0,(void*)getstack,1,"l","getstack(): current value of stack pointer avma."},
{"gettime",0,(void*)gettime,1,"l","gettime(): milliseconds of CPU time used since the last call to gettime."},
{"getwalltime",0,(void*)getwalltime,1,"","getwalltime(): time (in milliseconds) since the UNIX Epoch."},
{"global",0,NULL,1,NULL,"global(list of variables): obsolete. Scheduled for deletion."},
{"hammingweight",0,(void*)hammingweight,4,"lG","hammingweight(x): returns the Hamming weight of x."},
{"hilbert",0,(void*)hilbert,5,"lGGDG","hilbert(x,y,{p}): Hilbert symbol at p of x,y."},
{"hyperellcharpoly",0,(void*)hyperellcharpoly,12,"G","hyperellcharpoly(X): X being a non-singular hyperelliptic curve defined over a finite field, return the characteristic polynomial of the Frobenius automorphism.  X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree."},
{"hyperellpadicfrobenius",0,(void*)hyperellpadicfrobenius,12,"GUL","hyperellpadicfrobenius(Q,p,n): Q being a  rational polynomial of degree d and X being the curve defined by y^2=Q(x), return the matrix of the Frobenius at p>=d in the standard basis of H^1_dR(X) to absolute p-adic precision p^n."},
{"hyperellratpoints",0,(void*)hyperellratpoints,12,"GGD0,L,","hyperellratpoints(X,h,{flag=0}): X being a non-singular hyperelliptic curve given by an integral model, return a vector containing the affine rational points on the curve of naive height less than h. If fl=1, stop as soon as a point is found. X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)y=P(x) and Q^2+4P is squarefree."},
{"hyperu",0,(void*)hyperu,8,"GGGp","hyperu(a,b,x): U-confluent hypergeometric function."},
{"idealadd",0,(void*)idealadd,10,"GGG","idealadd(nf,x,y): sum of two ideals x and y in the number field defined by nf."},
{"idealaddtoone",0,(void*)idealaddtoone0,10,"GGDG","idealaddtoone(nf,x,{y}): if y is omitted, when the sum of the ideals in the number field K defined by nf and given in the vector x is equal to Z_K, gives a vector of elements of the corresponding ideals who sum to 1. Otherwise, x and y are ideals, and if they sum up to 1, find one element in each of them such that the sum is 1."},
{"idealappr",0,(void*)idealappr0,10,"GGD0,L,","idealappr(nf,x,{flag}): x being a fractional ideal, gives an element b such that v_p(b)=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p; x may also be a prime ideal factorization with possibly zero exponents. flag is deprecated (ignored), kept for backward compatibility."},
{"idealchinese",0,(void*)idealchinese,10,"GGDG","idealchinese(nf,x,{y}): x being a prime ideal factorization and y a vector of elements, gives an element b such that v_p(b-y_p)>=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p. If y is omitted, return a data structure which can be used in place of x in later calls."},
{"idealcoprime",0,(void*)idealcoprime,10,"GGG","idealcoprime(nf,x,y): gives an element b in nf such that b. x is an integral ideal coprime to the integral ideal y."},
{"idealdiv",0,(void*)idealdiv0,10,"GGGD0,L,","idealdiv(nf,x,y,{flag=0}): quotient x/y of two ideals x and y in HNF in the number field nf. If (optional) flag is non-null, the quotient is supposed to be an integral ideal (slightly faster)."},
{"idealfactor",0,(void*)gpidealfactor,10,"GGDG","idealfactor(nf,x,{lim}): factorization of the ideal x into prime ideals in the number field nf. If lim is set return partial factorization, using primes < lim."},
{"idealfactorback",0,(void*)idealfactorback,10,"GGDGD0,L,","idealfactorback(nf,f,{e},{flag = 0}): given a factorization f, gives the ideal product back. If e is present, f has to be a vector of the same length, and we return the product of the f[i]^e[i]. If flag is non-zero, perform idealred along the way."},
{"idealfrobenius",0,(void*)idealfrobenius,10,"GGG","idealfrobenius(nf,gal,pr): returns the Frobenius element (pr|nf/Q) attached to the unramified prime ideal pr in prid format, in the Galois group gal of the number field nf."},
{"idealhnf",0,(void*)idealhnf0,10,"GGDG","idealhnf(nf,u,{v}): hermite normal form of the ideal u in the number field nf if v is omitted. If called as idealhnf(nf,u,v), the ideal is given as uZ_K + vZ_K in the number field K defined by nf."},
{"idealintersect",0,(void*)idealintersect,10,"GGG","idealintersect(nf,A,B): intersection of two ideals A and B in the number field defined by nf."},
{"idealinv",0,(void*)idealinv,10,"GG","idealinv(nf,x): inverse of the ideal x in the number field nf."},
{"idealispower",0,(void*)idealispower,10,"lGGLD&","idealispower(nf,A,n,{&B}): return 1 if A = B^n is an n-th power else return 0."},
{"ideallist",0,(void*)ideallist0,10,"GLD4,L,","ideallist(nf,bound,{flag=4}): vector of vectors L of all idealstar of all ideals of norm<=bound. If (optional) flag is present, its binary digits are toggles meaning 1: give generators; 2: add units; 4: give only the ideals and not the bid."},
{"ideallistarch",0,(void*)ideallistarch,10,"GGG","ideallistarch(nf,list,arch): list is a vector of vectors of bid's as output by ideallist. Return a vector of vectors with the same number of components as the original list. The leaves give information about moduli whose finite part is as in original list, in the same order, and Archimedean part is now arch. The information contained is of the same kind as was present in the input."},
{"ideallog",0,(void*)ideallog,10,"DGGG","ideallog({nf},x,bid): if bid is a big ideal, as given by idealstar(nf,D,...), gives the vector of exponents on the generators bid.gen (even if these generators have not been explicitly computed)."},
{"idealmin",0,(void*)idealmin,10,"GGDG","idealmin(nf,ix,{vdir}): pseudo-minimum of the ideal ix in the direction vdir in the number field nf."},
{"idealmul",0,(void*)idealmul0,10,"GGGD0,L,","idealmul(nf,x,y,{flag=0}): product of the two ideals x and y in the number field nf. If (optional) flag is non-nul, reduce the result."},
{"idealnorm",0,(void*)idealnorm,10,"GG","idealnorm(nf,x): norm of the ideal x in the number field nf."},
{"idealnumden",0,(void*)idealnumden,10,"GG","idealnumden(nf,x): returns [A,B], where A,B are coprime integer ideals such that x = A/B."},
{"idealpow",0,(void*)idealpow0,10,"GGGD0,L,","idealpow(nf,x,k,{flag=0}): k-th power of the ideal x in HNF in the number field nf. If (optional) flag is non-null, reduce the result."},
{"idealprimedec",0,(void*)idealprimedec_limit_f,10,"GGD0,L,","idealprimedec(nf,p,{f=0}): prime ideal decomposition of the prime number p in the number field nf as a vector of prime ideals. If f is present and non-zero, restrict the result to primes of residue degree <= f."},
{"idealprincipalunits",0,(void*)idealprincipalunits,10,"GGL","idealprincipalunits(nf,pr,k): returns the structure [no, cyc, gen] of the multiplicative group (1 + pr) / (1 + pr^k)."},
{"idealramgroups",0,(void*)idealramgroups,10,"GGG","idealramgroups(nf,gal,pr): let pr be a prime ideal in prid format, and gal the Galois group of the number field nf, return a vector g such that g[1] is the decomposition group of pr, g[2] is the inertia group, g[i] is the (i-2)th ramification group of pr, all trivial subgroups being omitted."},
{"idealred",0,(void*)idealred0,10,"GGDG","idealred(nf,I,{v=0}): LLL reduction of the ideal I in the number field nf along direction v, in HNF."},
{"idealredmodpower",0,(void*)idealredmodpower,10,"GGUD0,U,","idealredmodpower(nf,x,n,{B=primelimit}): return b such that x * b^n = v is small."},
{"idealstar",0,(void*)idealstar0,10,"DGGD1,L,","idealstar({nf},N,{flag=1}): gives the structure of (Z_K/N)^*, where N is a modulus (an ideal in any form or a vector [f0, foo], where f0 is an ideal and foo is a {0,1}-vector with r1 components. flag is optional, and can be 0: simply gives the structure as an abelian group, i.e. a 3-component vector [h,d,g] where h is the order, d the orders of the cyclic factors and g the generators; if flag=1 (default), gives a bid structure used in ideallog to compute discrete logarithms; underlying generators are well-defined but not explicitly computed, which saves time; if flag=2, same as with flag=1 except that the generators are also given. If nf is omitted, N must be an integer and we return the structure of (Z/NZ)^*."},
{"idealtwoelt",0,(void*)idealtwoelt0,10,"GGDG","idealtwoelt(nf,x,{a}): two-element representation of an ideal x in the number field nf. If (optional) a is non-zero, first element will be equal to a."},
{"idealval",0,(void*)gpidealval,10,"GGG","idealval(nf,x,pr): valuation at pr given in idealprimedec format of the ideal x in the number field nf."},
{"if",0,(void*)ifpari,1,"GDEDE","if(a,{seq1},{seq2}): if a is nonzero, seq1 is evaluated, otherwise seq2. seq1 and seq2 are optional, and if seq2 is omitted, the preceding comma can be omitted also."},
{"iferr",0,(void*)iferrpari,1,"EVEDE","iferr(seq1,E,seq2,{pred}): evaluates the expression sequence seq1. If an error occurs, set the formal parameter E set to the error data. If pred is not present or evaluates to true, catch the error and evaluate seq2. Both pred and seq2 can reference E."},
{"imag",0,(void*)gimag,3,"G","imag(x): imaginary part of x."},
{"incgam",0,(void*)incgam0,8,"GGDGp","incgam(s,x,{g}): incomplete gamma function. g is optional and is the precomputed value of gamma(s)."},
{"incgamc",0,(void*)incgamc,8,"GGp","incgamc(s,x): complementary incomplete gamma function."},
{"inline",0,NULL,1,NULL,"inline(x,...,z): declares x,...,z as inline variables [EXPERIMENTAL]."},
{"input",0,(void*)gp_input,1,"","input(): read an expression from the input file or standard input."},
{"install",0,(void*)gpinstall,1,"vrrD\"\",r,D\"\",s,","install(name,code,{gpname},{lib}): load from dynamic library 'lib' the function 'name'. Assign to it the name 'gpname' in this GP session, with prototype 'code'. If 'lib' is omitted, all symbols known to gp (includes the whole 'libpari.so' and possibly others) are available. If 'gpname' is omitted, use 'name'."},
{"intcirc",0,(void*)intcirc0,9,"V=GGEDGp","intcirc(X=a,R,expr,{tab}): numerical integration of expr on the circle |z-a|=R, divided by 2*I*Pi. tab is as in intnum."},
{"intformal",0,(void*)integ,6,"GDn","intformal(x,{v}): formal integration of x with respect to v, or to the main variable of x if v is omitted."},
{"intfuncinit",0,(void*)intfuncinit0,9,"V=GGED0,L,p","intfuncinit(t=a,b,f,{m=0}): initialize tables for integrations from a to b using a weight f(t). For integral transforms such as Fourier or Mellin transforms."},
{"intnum",0,(void*)intnum0,9,"V=GGEDGp","intnum(X=a,b,expr,{tab}): numerical integration of expr from a to b with respect to X. Plus/minus infinity is coded as +oo/-oo. Finally tab is either omitted (let the program choose the integration step), a non-negative integer m (divide integration step by 2^m), or data precomputed with intnuminit."},
{"intnumgauss",0,(void*)intnumgauss0,9,"V=GGEDGp","intnumgauss(X=a,b,expr,{tab}): numerical integration of expr from a to b, a compact interval, with respect to X using Gauss-Legendre quadrature. tab is either omitted (and will be recomputed) or precomputed with intnumgaussinit."},
{"intnumgaussinit",0,(void*)intnumgaussinit,9,"D0,L,p","intnumgaussinit({n}): initialize tables for n-point Gauss-Legendre integration on a compact interval."},
{"intnuminit",0,(void*)intnuminit,9,"GGD0,L,p","intnuminit(a,b,{m=0}): initialize tables for integrations from a to b. See help for intnum for coding of a and b. Possible types: compact interval, semi-compact (one extremity at + or - infinity) or R, and very slowly, slowly or exponentially decreasing, or sine or cosine oscillating at infinities."},
{"intnumromb",0,(void*)intnumromb0_bitprec,9,"V=GGED0,L,b","intnumromb(X=a,b,expr,{flag=0}): numerical integration of expr (smooth in ]a,b[) from a to b with respect to X. flag is optional and mean 0: default. expr can be evaluated exactly on [a,b]; 1: general function; 2: a or b can be plus or minus infinity (chosen suitably), but of same sign; 3: expr has only limits at a or b."},
{"isfundamental",0,(void*)isfundamental,5,"lG","isfundamental(D): true(1) if D is a fundamental discriminant (including 1), false(0) if not."},
{"ispolygonal",0,(void*)ispolygonal,5,"lGGD&","ispolygonal(x,s,{&N}): true(1) if x is an s-gonal number, false(0) if not (s > 2). If N is given set it to n if x is the n-th s-gonal number."},
{"ispower",0,(void*)ispower,5,"lGDGD&","ispower(x,{k},{&n}): if k > 0 is given, return true (1) if x is a k-th power, false (0) if not. If k is omitted, return the maximal k >= 2 such that x = n^k is a perfect power, or 0 if no such k exist. If n is present, and the function returns a non-zero result, set n to the k-th root of x."},
{"ispowerful",0,(void*)ispowerful,5,"lG","ispowerful(x): true(1) if x is a powerful integer (valuation at all primes dividing x is greater than 1), false(0) if not."},
{"isprime",0,(void*)gisprime,5,"GD0,L,","isprime(x,{flag=0}): true(1) if x is a (proven) prime number, false(0) if not. If flag is 0 or omitted, use a combination of algorithms. If flag is 1, the primality is certified by the Pocklington-Lehmer Test. If flag is 2, the primality is certified using the APRCL test. If flag is 3, use ECPP."},
{"isprimepower",0,(void*)isprimepower,5,"lGD&","isprimepower(x,{&n}): if x = p^k is a prime power (p prime, k > 0), return k, else return 0. If n is present, and the function returns a non-zero result, set n to p, the k-th root of x."},
{"ispseudoprime",0,(void*)gispseudoprime,5,"GD0,L,","ispseudoprime(x,{flag}): true(1) if x is a strong pseudoprime, false(0) if not. If flag is 0 or omitted, use BPSW test, otherwise use strong Rabin-Miller test for flag randomly chosen bases."},
{"ispseudoprimepower",0,(void*)ispseudoprimepower,5,"lGD&","ispseudoprimepower(x,{&n}): if x = p^k is a pseudo-prime power (p pseudo-prime, k > 0), return k, else return 0. If n is present, and the function returns a non-zero result, set n to p, the k-th root of x."},
{"issquare",0,(void*)issquareall,5,"lGD&","issquare(x,{&n}): true(1) if x is a square, false(0) if not. If n is given puts the exact square root there if it was computed."},
{"issquarefree",0,(void*)issquarefree,5,"lG","issquarefree(x): true(1) if x is squarefree, false(0) if not."},
{"istotient",0,(void*)istotient,5,"lGD&","istotient(x,{&N}): true(1) if x = eulerphi(n) for some integer n, false(0) if not. If N is given, set N = n as well."},
{"kill",0,(void*)kill0,1,"vr","kill(sym): restores the symbol sym to its ``undefined'' status and kill attached help messages."},
{"kronecker",0,(void*)kronecker,5,"lGG","kronecker(x,y): kronecker symbol (x/y)."},
{"lambertw",0,(void*)glambertW,8,"Gp","lambertw(y): solution of the implicit equation x*exp(x)=y."},
{"laurentseries",0,(void*)laurentseries0,9,"GDPDnp","laurentseries(f, {M = seriesprecision}, {x='x}): expand f around 0 as a Laurent series in x to order M."},
{"lcm",0,(void*)glcm0,5,"GDG","lcm(x,{y}): least common multiple of x and y, i.e. x*y / gcd(x,y) up to units."},
{"length",0,(void*)glength,3,"lG","length(x): number of non code words in x, number of characters for a string."},
{"lex",0,(void*)lexcmp,2,"iGG","lex(x,y): compare x and y lexicographically (1 if x>y, 0 if x=y, -1 if x<y)."},
{"lfun",0,(void*)lfun0,13,"GGD0,L,b","lfun(L,s,{D=0}): compute the L-function value L(s), or if D is set, the derivative of order D at s. L is either an Lmath, an Ldata or an Linit."},
{"lfunabelianrelinit",0,(void*)lfunabelianrelinit,13,"GGGGD0,L,b","lfunabelianrelinit(bnfL,bnfK,polrel,sdom,{der=0}): returns the  Linit structure attached to the Dedekind zeta function of the number field  L, given a subfield K such that L/K is abelian, where polrel defines  L over K. The priority of the variable  of bnfK must be lower than that of polrel; bnfL is the absolute polynomial  corresponding to polrel, and sdom and der are as in lfuninit."},
{"lfunan",0,(void*)lfunan,13,"GLp","lfunan(L,n): compute the first n terms of the Dirichlet series  attached to the L-function given by L (Lmath, Ldata or Linit)."},
{"lfunartin",0,(void*)lfunartin,13,"GGGLb","lfunartin(nf,gal,rho,n): returns the Ldata structure attached to the Artin L-function provided by the representation rho of the Galois group of the extension K/Q, defined over the cyclotomic field Q(zeta_n), where nf is the nfinit structure attached to K, gal is the galoisinit structure attached to K/Q, and rho is given either by the values of its character on the conjugacy classes or by the matrices that are the images of the generators. Cyclotomic numbers in rho are represented by polynomials, whose variable is understood as the complex number exp(2*I*Pi/n)."},
{"lfuncheckfeq",0,(void*)lfuncheckfeq,13,"lGDGb","lfuncheckfeq(L,{t}): given an L-function (Lmath, Ldata or Linit), check whether the functional equation is satisfied. If the function has poles, the polar part must be specified. The program returns a bit accuracy which should be a large negative value close to the current bit accuracy. If t is given, it checks the functional equation for the theta function at t and 1/t."},
{"lfunconductor",0,(void*)lfunconductor,13,"GDGD0,L,b","lfunconductor(L,{ab=[1,10000]},{flag=0}): give the conductor  of the given L-function; ab = [a,b] is the interval where we expect  to find the conductor.  If flag=0 (default), give either the conductor found as an integer, or a  vector (possibly empty) of conductors found. If flag=1, same but give the  computed floating point approximations to the conductors found, without  rounding to integers.  If flag=2, give all the conductors found, even those far from integers.  Note: this program is heuristic and should only be used if the primes  dividing the conductor are unknown. If they are known, a direct search  through possible prime exponents using lfuncheckfeq will be more efficient."},
{"lfuncost",0,(void*)lfuncost0,13,"GDGD0,L,b","lfuncost(L,{sdom},{der=0}): estimate the cost of running lfuninit(L,sdom,der) at current bit precision. Returns [t,b], to indicate that t coefficients a_n will be computed at bit accuracy b. Subsequent evaluation of lfun at s evaluates a polynomial of degree t at exp(h s). If L is already an Linit, then sdom and der are ignored."},
{"lfuncreate",0,(void*)lfuncreate,13,"G","lfuncreate(obj): given either an object such as a polynomial, elliptic curve, Dirichlet or Hecke character, eta quotient, etc., or an explicit 6 or 7 component vector [dir,real,Vga,k,N,eps,r], create the Ldata structure necessary for lfun computation."},
{"lfundiv",0,(void*)lfundiv,13,"GGb","lfundiv(L1,L2): creates the Ldata structure (without  initialization) corresponding to the quotient of the Dirichlet series  given by L1 and L2."},
{"lfunetaquo",0,(void*)lfunetaquo,13,"G","lfunetaquo(M): returns the Ldata structure attached to the modular form z->prod(i=1,#M[,1],eta(M[i,1]*z)^M[i,2])."},
{"lfungenus2",0,(void*)lfungenus2,13,"G","lfungenus2(F): returns the Ldata structure attached to the L-function attached to the genus-2 curve defined by y^2=F(x) or y^2+Q(x)*y=P(x) if F=[P,Q]. Currently, only odd conductors are supported, and the model needs to be minimal at 2."},
{"lfunhardy",0,(void*)lfunhardy,13,"GGb","lfunhardy(L,t): variant of the Hardy L-function attached to L, used for plotting on the critical line."},
{"lfuninit",0,(void*)lfuninit0,13,"GGD0,L,b","lfuninit(L,sdom,{der=0}): precompute data for evaluating the L-function given by 'L' (and its derivatives of order der, if set) in rectangular domain sdom = [center,w,h] centered on the real axis, |Re(s)-center| <= w, |Im(s)| <= h, where all three components of sdom are real and w,h are non-negative. The subdomain [k/2, 0, h] on the critical line can be encoded as [h] for brevity."},
{"lfunlambda",0,(void*)lfunlambda0,13,"GGD0,L,b","lfunlambda(L,s,{D=0}): compute the completed L function Lambda(s), or if D is set, the derivative of order D at s. L is either an Lmath, an Ldata or an Linit."},
{"lfunmf",0,(void*)lfunmf,14,"GDGb","lfunmf(mf,{F}): If F is a modular form in mf, output the L-functions corresponding to its complex embeddings. If F is omitted, output the L-functions corresponding to all eigenforms in the new space."},
{"lfunmfspec",0,(void*)lfunmfspec,13,"Gb","lfunmfspec(L): L corresponding to a modular form, returns  [valeven,valodd,omminus,omplus], where valeven (resp., valodd) is the vector  of even (resp., odd) periods, and omminus and omplus the corresponding  real numbers omega^- and omega^+. For the moment, only for modular forms of even weight."},
{"lfunmul",0,(void*)lfunmul,13,"GGb","lfunmul(L1,L2): creates the Ldata structure (without  initialization) corresponding to the product of the Dirichlet series  given by L1 and L2."},
{"lfunorderzero",0,(void*)lfunorderzero,13,"lGD-1,L,b","lfunorderzero(L, {m = -1}): computes the order of the possible zero of the L-function at the center k/2 of the critical strip. If m is given and has a non-negative value, assumes the order is at most m."},
{"lfunqf",0,(void*)lfunqf,13,"Gp","lfunqf(Q): returns the Ldata structure attached to the theta function of the lattice attached to the definite positive quadratic form Q."},
{"lfunrootres",0,(void*)lfunrootres,13,"Gb","lfunrootres(data): given the Ldata attached to an L-function (or the output of lfunthetainit), compute the root number and the residues. In the present implementation, if the polar part is not already known completely, at most a single pole is allowed. The output is a 3-component vector  [[[a_1, r_1],...,[a_n, r_n],[[b_1, R_1],...[b_m,R_m]], w], where r_i is the  polar part of L(s) at a_i, R_i is is the polar part of Lambda(s) at b_i,  or [0,0,r] if there is no pole, and w is the root number."},
{"lfunsympow",0,(void*)lfunsympow,13,"GU","lfunsympow(E, m): returns the Ldata structure attached to the L-function attached to m-th symmetric power of the elliptic curve E defined over the rationals."},
{"lfuntheta",0,(void*)lfuntheta,13,"GGD0,L,b","lfuntheta(data,t,{m=0}): compute the value of the m-th derivative at t of the theta function attached to the L-function given by data. data can be either the standard L-function data, or the output of lfunthetainit."},
{"lfunthetacost",0,(void*)lfunthetacost0,13,"lGDGD0,L,b","lfunthetacost(L,{tdom},{m=0}): estimates the cost of running lfunthetainit(L,tdom,m) at current bit precision. Returns the number of coefficients an that would be computed. Subsequent evaluation of lfuntheta computes that many values of gammamellininv. If L is already an Linit, then tdom and m are ignored."},
{"lfunthetainit",0,(void*)lfunthetainit,13,"GDGD0,L,b","lfunthetainit(L,{tdom},{m=0}): precompute data for evaluating  the m-th derivative of theta functions with argument in domain tdom  (by default t is real >= 1)."},
{"lfuntwist",0,(void*)lfuntwist,13,"GG","lfuntwist(L,chi): creates the Ldata structure (without initialization) corresponding to the twist of L by the primitive character attached to the Dirichlet L-function chi. This requires that the conductor of the character is coprime to the conductor of the L-function L."},
{"lfunzeros",0,(void*)lfunzeros,13,"GGD8,L,b","lfunzeros(L,lim,{divz=8}): lim being either an upper limit or a real interval, computes an ordered list of zeros of L(s) on the critical line up to the given upper limit or in the given interval. Use a naive algorithm which may miss some zeros. To use a finer search mesh, set divz to some integral value larger than the default (= 8)."},
{"lift",0,(void*)lift0,3,"GDn","lift(x,{v}): if v is omitted, lifts elements of Z/nZ to Z, of Qp to Q, and of K[x]/(P) to K[x]. Otherwise lift only polmods with main variable v."},
{"liftall",0,(void*)liftall,3,"G","liftall(x): lifts every element of Z/nZ to Z, of Qp to Q, and of K[x]/(P) to K[x]."},
{"liftint",0,(void*)liftint,3,"G","liftint(x): lifts every element of Z/nZ to Z, of Qp to Q, and of K[x]/(P) to K[x]."},
{"liftpol",0,(void*)liftpol,3,"G","liftpol(x): lifts every polmod component of x to polynomials."},
{"limitnum",0,(void*)limitnum0,9,"GD0,L,DGp","limitnum(expr,{k = 20},{alpha=1}): numerical limit of sequence expr using Lagrange-Zagier extrapolation; k is a multiplier so that we extrapolate from expr(k*n). Assume u(n) ~ sum a_i n^(-alpha*i)."},
{"lindep",0,(void*)lindep0,7,"GD0,L,","lindep(v,{flag=0}): integral linear dependencies between components of v. flag is optional, and can be 0: default, guess a suitable accuracy, or positive: accuracy to use for the computation, in decimal digits."},
{"listcreate",0,(void*)listcreate_gp,1,"D0,L,","listcreate({n}): this function is obsolete, use List()."},
{"listinsert",0,(void*)listinsert,1,"WGL","listinsert(L,x,n): insert x at index n in list L, shifting the remaining elements to the right."},
{"listkill",0,(void*)listkill,1,"vG","listkill(L): obsolete, retained for backward compatibility."},
{"listpop",0,(void*)listpop0,1,"vWD0,L,","listpop(list,{n}): removes n-th element from list. If n is omitted or greater than the current list length, removes last element."},
{"listput",0,(void*)listput0,1,"WGD0,L,","listput(list,x,{n}): sets n-th element of list equal to x. If n is omitted or greater than the current list length, appends x."},
{"listsort",0,(void*)listsort,1,"vWD0,L,","listsort(L,{flag=0}): sort the list L in place. If flag is non-zero, suppress all but one occurence of each element in list."},
{"lngamma",0,(void*)glngamma,8,"Gp","lngamma(x): logarithm of the gamma function of x."},
{"local",0,NULL,1,NULL,"local(x,...,z): declare x,...,z as (dynamically scoped) local variables."},
{"localbitprec",0,(void*)localbitprec,1,"vL","localbitprec(p): set the real precision to p bits in the dynamic scope."},
{"localprec",0,(void*)localprec,1,"vL","localprec(p): set the real precision to p in the dynamic scope."},
{"log",0,(void*)glog,8,"Gp","log(x): natural logarithm of x."},
{"log1p",0,(void*)glog1p,8,"Gp","log1p(x): log(1+x)"},
{"logint",0,(void*)logint0,5,"lGGD&","logint(x,b,{&z}): return the largest integer e so that b^e <= x, where the parameters b > 1 and x > 0 are both integers. If the parameter z is present, set it to b^e."},
{"mapdelete",0,(void*)mapdelete,1,"vGG","mapdelete(M,x): removes x from the domain of the map M."},
{"mapget",0,(void*)mapget,1,"GG","mapget(M,x): returns the image of x by the map M."},
{"mapisdefined",0,(void*)mapisdefined,1,"iGGD&","mapisdefined(M,x,{&z}): true (1) if x has an image by the map M, false (0) otherwise. If z is present, set it to the image of x, if it exists."},
{"mapput",0,(void*)mapput,1,"vWGG","mapput(M,x,y): associates x to y in the map M."},
{"matadjoint",0,(void*)matadjoint0,7,"GD0,L,","matadjoint(M,{flag=0}): adjoint matrix of M using Leverrier-Faddeev's algorithm. If flag is 1, compute the characteristic polynomial independently first."},
{"matalgtobasis",0,(void*)matalgtobasis,10,"GG","matalgtobasis(nf,x): nfalgtobasis applied to every element of the vector or matrix x."},
{"matbasistoalg",0,(void*)matbasistoalg,10,"GG","matbasistoalg(nf,x): nfbasistoalg applied to every element of the matrix or vector x."},
{"matcompanion",0,(void*)matcompanion,7,"G","matcompanion(x): companion matrix to polynomial x."},
{"matconcat",0,(void*)matconcat,7,"G","matconcat(v): concatenate the entries of v and return the resulting matrix."},
{"matdet",0,(void*)det0,7,"GD0,L,","matdet(x,{flag=0}): determinant of the matrix x using an appropriate algorithm depending on the coefficients. If (optional) flag is set to 1, use classical Gaussian elimination (usually worse than the default)."},
{"matdetint",0,(void*)detint,7,"G","matdetint(B): some multiple of the determinant of the lattice generated by the columns of B (0 if not of maximal rank). Useful with mathnfmod."},
{"matdetmod",0,(void*)matdetmod,7,"GG","matdetmod(x,d): determinant of the matrix x modulo d."},
{"matdiagonal",0,(void*)diagonal,7,"G","matdiagonal(x): creates the diagonal matrix whose diagonal entries are the entries of the vector x."},
{"mateigen",0,(void*)mateigen,7,"GD0,L,p","mateigen(x,{flag=0}): complex eigenvectors of the matrix x given as columns of a matrix H. If flag=1, return [L,H], where L contains the eigenvalues and H the corresponding eigenvectors."},
{"matfrobenius",0,(void*)matfrobenius,7,"GD0,L,Dn","matfrobenius(M,{flag},{v='x}): return the Frobenius form of the square matrix M. If flag is 1, return only the elementary divisors as a vector of polynomials in the variable v. If flag is 2, return a two-components vector [F,B] where F is the Frobenius form and B is the basis change so that M=B^-1*F*B."},
{"mathess",0,(void*)hess,7,"G","mathess(x): Hessenberg form of x."},
{"mathilbert",0,(void*)mathilbert,7,"L","mathilbert(n): Hilbert matrix of order n."},
{"mathnf",0,(void*)mathnf0,7,"GD0,L,","mathnf(M,{flag=0}): (upper triangular) Hermite normal form of M, basis for the lattice formed by the columns of M. flag is optional whose value range from 0 to 3 have a binary meaning. Bit 1: complete output, returns a 2-component vector [H,U] such that H is the HNF of M, and U is an invertible matrix such that MU=H. Bit 2: allow polynomial entries, otherwise assume that M is integral. These use a naive algorithm; larger values correspond to more involved algorithms and are restricted to integer matrices; flag = 4: returns [H,U] using LLL reduction along the way; flag = 5: return [H,U,P] where P is a permutation of row indices such that P applied to M U is H."},
{"mathnfmod",0,(void*)hnfmod,7,"GG","mathnfmod(x,d): (upper triangular) Hermite normal form of x, basis for the lattice formed by the columns of x, where d is a multiple of the non-zero determinant of this lattice."},
{"mathnfmodid",0,(void*)hnfmodid,7,"GG","mathnfmodid(x,d): (upper triangular) Hermite normal form of x concatenated with matdiagonal(d)."},
{"mathouseholder",0,(void*)mathouseholder,7,"GG","mathouseholder(Q,v): applies a sequence Q of Householder transforms to the vector or matrix v."},
{"matid",0,(void*)matid,7,"L","matid(n): identity matrix of order n."},
{"matimage",0,(void*)matimage0,7,"GD0,L,","matimage(x,{flag=0}): basis of the image of the matrix x. flag is optional and can be set to 0 or 1, corresponding to two different algorithms."},
{"matimagecompl",0,(void*)imagecompl,7,"G","matimagecompl(x): vector of column indices not corresponding to the indices given by the function matimage."},
{"matimagemod",0,(void*)matimagemod,7,"GGD&","matimagemod(x,d,&U): basis of the image of the matrix x modulo d."},
{"matindexrank",0,(void*)indexrank,7,"G","matindexrank(M): gives two extraction vectors (rows and columns) for the matrix M such that the extracted matrix is square of maximal rank."},
{"matintersect",0,(void*)intersect,7,"GG","matintersect(x,y): intersection of the vector spaces whose bases are the columns of x and y."},
{"matinverseimage",0,(void*)inverseimage,7,"GG","matinverseimage(x,y): an element of the inverse image of the vector y by the matrix x if one exists, the empty vector otherwise."},
{"matinvmod",0,(void*)matinvmod,7,"GG","matinvmod(x,d): left inverse of the matrix x modulo d."},
{"matisdiagonal",0,(void*)isdiagonal,7,"iG","matisdiagonal(x): true(1) if x is a diagonal matrix, false(0) otherwise."},
{"matker",0,(void*)matker0,7,"GD0,L,","matker(x,{flag=0}): basis of the kernel of the matrix x. flag is optional, and may be set to 0: default; non-zero: x is known to have integral entries."},
{"matkerint",0,(void*)matkerint0,7,"GD0,L,","matkerint(x,{flag=0}): LLL-reduced Z-basis of the kernel of the matrix x with integral entries. flag is deprecated, and may be set to 0 or 1 for backward compatibility."},
{"matkermod",0,(void*)matkermod,7,"GGD&","matkermod(x,d,&im): basis of the kernel of the matrix x modulo d."},
{"matmuldiagonal",0,(void*)matmuldiagonal,7,"GG","matmuldiagonal(x,d): product of matrix x by diagonal matrix whose diagonal coefficients are those of the vector d, equivalent but faster than x*matdiagonal(d)."},
{"matmultodiagonal",0,(void*)matmultodiagonal,7,"GG","matmultodiagonal(x,y): product of matrices x and y, knowing that the result will be a diagonal matrix. Much faster than general multiplication in that case."},
{"matpascal",0,(void*)matqpascal,7,"LDG","matpascal(n,{q}): Pascal triangle of order n if q is omitted. q-Pascal triangle otherwise."},
{"matpermanent",0,(void*)matpermanent,7,"G","matpermanent(x): permanent of the matrix x."},
{"matqr",0,(void*)matqr,7,"GD0,L,p","matqr(M,{flag=0}): returns [Q,R], the QR-decomposition of the square invertible matrix M. If flag=1, Q is given as a sequence of Householder transforms (faster and stabler)."},
{"matrank",0,(void*)rank,7,"lG","matrank(x): rank of the matrix x."},
{"matrix",0,(void*)matrice,7,"GDGDVDVDE","matrix(m,{n=m},{X},{Y},{expr=0}): m x n matrix of expression expr, where the row variable X goes from 1 to m and the column variable Y goes from 1 to n. By default, fill with 0s."},
{"matrixqz",0,(void*)matrixqz0,7,"GDG","matrixqz(A,{p=0}): if p>=0, transforms the rational or integral mxn (m>=n) matrix A into an integral matrix with gcd of maximal determinants coprime to p. If p=-1, finds a basis of the intersection with Z^n of the lattice spanned by the columns of A. If p=-2, finds a basis of the intersection with Z^n of the Q-vector space spanned by the columns of A."},
{"matsize",0,(void*)matsize,7,"G","matsize(x): number of rows and columns of the vector/matrix x as a 2-vector."},
{"matsnf",0,(void*)matsnf0,7,"GD0,L,","matsnf(X,{flag=0}): Smith normal form (i.e. elementary divisors) of the matrix X, expressed as a vector d. Binary digits of flag mean 1: returns [u,v,d] where d=u*X*v, otherwise only the diagonal d is returned, 2: allow polynomial entries, otherwise assume X is integral, 4: removes all information corresponding to entries equal to 1 in d."},
{"matsolve",0,(void*)gauss,7,"GG","matsolve(M,B): solution of MX=B (M matrix, B column vector or matrix)."},
{"matsolvemod",0,(void*)matsolvemod,7,"GGGD0,L,","matsolvemod(M,D,B,{flag=0}): one solution of system of congruences MX=B mod D (M matrix, B and D column vectors). If (optional) flag is non-null return all solutions."},
{"matsupplement",0,(void*)suppl,7,"G","matsupplement(x): supplement the columns of the matrix x to an invertible matrix."},
{"mattranspose",0,(void*)gtrans,7,"G","mattranspose(x): x~ = transpose of x."},
{"max",0,(void*)gmax,2,"GG","max(x,y): maximum of x and y."},
{"mfDelta",0,(void*)mfDelta,14,"","mfDelta(): mf corresponding to the Ramanujan Delta function."},
{"mfEH",0,(void*)mfEH,14,"G","mfEH(k): k being in 1/2+Z, mf corresponding to the Cohen-Eisenstein series H_k of weight k on G_0(4)."},
{"mfEk",0,(void*)mfEk,14,"L","mfEk(k): mf corresponding to the standard Eisenstein series E_k."},
{"mfTheta",0,(void*)mfTheta,14,"DG","mfTheta({psi=1}): the unary theta function corresponding to the primitive Dirichlet character psi, hence of weight 1/2 if psi is even, of weight 3/2 if psi is odd."},
{"mfatkin",0,(void*)mfatkin,14,"GG","mfatkin(mfatk,F): Given an mfatk output by mfatk = mfatkininit(mf,Q) and a modular form F belonging to the space mf, returns the modular form C*F|W_Q, which has polmod coefficients in Q(F), and where mfatk[3]=C, mfatk[1]=mf2 (or 0 if mf2=mf) which is the space to which F|W_Q belongs."},
{"mfatkineigenvalues",0,(void*)mfatkineigenvalues,14,"GLp","mfatkineigenvalues(mf,Q): given a modular form space mf and a primitive divisor Q of the level of mf, outputs the corresponding Atkin-Lehner eigenvalues on the new space, grouped by orbit."},
{"mfatkininit",0,(void*)mfatkininit,14,"GLp","mfatkininit(mf,Q): initializes data necessary for working with Atkin--Lehner operators W_Q, for now only the function mfatkin. The result is a 4-component vector [mfB, CM, C, mf] where mfB is either 0 or the possibly different modular form space to which F|W_Q will belong (this does not depend on F in mf); CM is the matrix of W_Q on the basis of mf multiplied by a normalizing constant C."},
{"mfbasis",0,(void*)mfbasis,14,"GD4,L,","mfbasis(NK,{space=4}): If NK=[N,k,CHI] as in mfinit, gives a basis of the corresponding subspace of M_k(G_0(N),chi). NK can also be the output of mfinit, in which case space is ignored. To obtain the eigenforms use mfeigenbasis."},
{"mfbd",0,(void*)mfbd,14,"GL","mfbd(F,d): F being a generalized modular form, return B(d)(F), where B(d) is the expanding operator tau -> d tau."},
{"mfbracket",0,(void*)mfbracket,14,"GGD0,L,","mfbracket(F,G,{m=0}): compute the m-th Rankin-Cohen bracket of the generalized modular forms F and G."},
{"mfcoef",0,(void*)mfcoef,14,"GL","mfcoef(F,n): Compute the n-th Fourier coefficient a(n) of the modular form F."},
{"mfcoefs",0,(void*)mfcoefs,14,"GLD1,L,","mfcoefs(F,n,{d = 1}): Compute the vector of coefficients [a[0],a[d],...,a[nd]] of the modular form F."},
{"mfconductor",0,(void*)mfconductor,14,"lGG","mfconductor(mf,F): mf being output by mfinit for the cuspidal space and F a modular form, gives the smallest level on which F is defined."},
{"mfcosets",0,(void*)mfcosets,14,"G","mfcosets(N): list of right cosets of G_0(N)\\G, i.e., matrices ga_j in G such that G=U G_0(N)ga_j. The ga_j are chosen in the form [a,b;c,d] with c\\mid N. N can be either a positive integer or a modular form space."},
{"mfcuspisregular",0,(void*)mfcuspisregular,14,"lGG","mfcuspisregular(NK, cusp): In the space defined by NK = [N,k,CHI] or NK = mf, determine if cusp in canonical format (oo or denominator dividing N) is regular or not."},
{"mfcusps",0,(void*)mfcusps,14,"G","mfcusps(N): list of cusps of G_0(N) in the form a/b with b dividing N. N can be either an integer or a modular form space."},
{"mfcuspval",0,(void*)mfcuspval,14,"GGGb","mfcuspval(mf,F,cusp): valuation of modular form F in the space mf at cusp, which can be either oo or any rational number, and the result is either a rational number or oo if F is zero. If Q(F) != Q(chi), return the vector of valuations attached to the [Q(F):Q(chi)] complex embeddings of F."},
{"mfcuspwidth",0,(void*)mfcuspwidth,14,"lGG","mfcuspwidth(N, cusp): width of cusp in Gamma_0(N), N being either an integer or a modular form space."},
{"mfderiv",0,(void*)mfderiv,14,"GD1,L,","mfderiv(F,{m=1}): m-th formal derivative of the power series corresponding to the generalized modular form F, with respect to the differential operator q.d/dq (default m=1)."},
{"mfderivE2",0,(void*)mfderivE2,14,"GD1,L,","mfderivE2(F,{m=1}): compute the Serre derivative (q.d/dq)F - kE_2F/12 of the generalized modular form F of weight k; and if m > 1, the m-th iterate."},
{"mfdescribe",0,(void*)mfdescribe,14,"GD&","mfdescribe(F,{&G}): gives a human-readable description of F, which is either a modular form space or a modular form. If the address of G is given, puts into G the vector of parameters of the outmost operator defining F (the empty vector if F is a leaf or a modular form space)."},
{"mfdim",0,(void*)mfdim,14,"GD4,L,","mfdim(NK,{space=4}): If NK=[N,k,CHI] as in mfinit, gives the dimension of the corresponding subspace of M_k(G_0(N),chi). The subspace is described by a small integer 'space': 0 for the newspace, 1 for the cuspidal space, 2 for the oldspace, 3 for the space of Eisenstein series and 4 (default) for the full space M_k. NK can also be the output of mfinit, in which case space must be omitted."},
{"mfdiv",0,(void*)mfdiv,14,"GG","mfdiv(F,G): compute F/G for two modular forms F and G assuming that the quotient will not have poles at infinity. If this is the case, use mfshift before doing the division."},
{"mfeigenbasis",0,(void*)mfeigenbasis,14,"G","mfeigenbasis(mf): vector of the eigenforms for the space mf."},
{"mfeigensearch",0,(void*)mfeigensearch,14,"GDG","mfeigensearch(NK,{AP}): search for normalized rational eigen cuspforms with quadratic characters given a few initial coefficients. The meaning of the parameters is as follows:  NK is of the form [N,k]: search given level N, weight k and quadratic character; note that the character is uniquely determined by (N,k). The level N can be replaced by a vector of allowed levels.  AP is the search criterion, which can be omitted: a list of pairs [...,[p,a_p],...], where a_p is either a t_INT (exact match) or a t_INTMOD (match modulo the given integer).  The result is a vector of newforms matching the search criteria, sorted by increasing level."},
{"mfeisenstein",0,(void*)mfeisenstein,14,"LDGDG","mfeisenstein(k,{CHI1},{CHI2}): create the Eisenstein E_k(CHI1,CHI2), where an omitted character is considered as trivial."},
{"mfembed",0,(void*)mfembed0,14,"GDGp","mfembed(f,{v}): if v is omitted, f must be a modular form or a modular form space with parameters [N,k,chi] and we return a vector of complex embeddings of Q(f) or Q(chi), respectively.  If v is given, it must be a scalar in Q(f), or a vector/matrix of such, we apply the embeddings coefficientwise and return a vector of results. Finally f can be replaced by a single embedding produced by mfembed(f) and we apply that particular embedding to v. Note that, in our context, Q(chi) has a single canonical embeding given by s: Mod(t, polcyclo(n,t)) -> exp(2*I*Pi/n) and Q(f) has [Q(f):Q(chi)] induced embeddings attached to the complex roots of s(P) where P = mfparams(f)[4], as ordered by polroots. In the latter case, we only support an f with Q(f) = Q(chi) or an eigenform produced by mfeigenbasis."},
{"mfeval",0,(void*)mfeval,14,"GGGb","mfeval(mf,F,vtau): computes the numerical value of the modular form F at the point vtau or the vector vtau of points in the completed upper-half plane."},
{"mffields",0,(void*)mffields,14,"G","mffields(mf): If mf is output by mfinit, gives the vector of polynomials defining each Galois orbit of the new space."},
{"mffromell",0,(void*)mffromell,14,"G","mffromell(E): E being an elliptic curve defined over Q given by an integral model in ellinit format, computes a 3-component vector [mf,F,v], where F is the newform corresponding to E by modularity, mf is the newspace to which F belongs, and v gives the coefficients of F on mfbasis(mf)."},
{"mffrometaquo",0,(void*)mffrometaquo,14,"GD0,L,","mffrometaquo(eta,{flag=0}): modular form corresponding to the eta quotient matrix eta. If the valuation v at infinity is fractional, return 0. If the eta quotient is not holomorphic but simply meromorphic, return 0 if flag=0, return the eta quotient (divided by q to the power -v if v < 0, i.e., with valuation 0) if flag is set."},
{"mffromlfun",0,(void*)mffromlfun,14,"Gp","mffromlfun(L): L being an L-function representing a self-dual modular form, return [NK,space,v] where mf=mfinit(NK,space) contains the form and mftobasis(mf, v) containing it and v is mftobasis(mf,f)."},
{"mffromqf",0,(void*)mffromqf,14,"GDG","mffromqf(Q,{P}): Q being an even positive definite quadratic form and P a homogeneous spherical polynomial for Q, computes a 3-component vector [mf,F,coeffs], where F is the theta function corresponding to (Q, P), mf is the corresponding space of modular forms from mfinit, and coeffs are the coefficients of F on mfbasis(mf)."},
{"mfgaloistype",0,(void*)mfgaloistype,14,"GDG","mfgaloistype(NK,{F}): NK being either [N,1,CHI] or an mf output by mfinit in weight 1 , gives the vector of types of Galois representations attached to each cuspidal eigenform, unless the eigenform F is specified, in which case only for F. Types A_4, S_4, A_5 are represented by minus their cardinality -12, -24, or -60, and type D_n is represented by its cardinality, the integer 2*n."},
{"mfhecke",0,(void*)mfhecke,14,"GGL","mfhecke(mf,F,n): F being a modular form in space mf, returns T(n)F, where T(n) is the n-th Hecke operator. Warning: if F is of level M<N, T(n)F is in general not the same in M_k(G_0(M),CHI) and in M_k(G_0(N),CHI). We take T(n) at the same level as the one used in mf."},
{"mfheckemat",0,(void*)mfheckemat,14,"GG","mfheckemat(mf,vecn): if vecn is an integer, matrix of the Hecke operator T(n) on the basis formed by mfbasis(mf), if it is a vector, vector of such matrices."},
{"mfinit",0,(void*)mfinit,14,"GD4,L,","mfinit(NK,{space=4}): Create the space of modular forms corresponding to the data contained in NK and space. NK is a vector which can be either [N,k] (N level, k weight) corresponding to a subspace of M_k(G_0(N)), or [N,k,CHI] (CHI a character) corresponding to a subspace of M_k(G_0(N),chi). The subspace is described by a small integer 'space': 0 for the newspace, 1 for the cuspidal space, 2 for the oldspace, 3 for the space of Eisenstein series and 4 (default) for the full space M_k"},
{"mfisCM",0,(void*)mfisCM,14,"G","mfisCM(F): Tests whether the eigenform F is a CM form. The answer is 0 if it is not, and if it is, either the unique negative discriminant of the CM field, or the pair of two negative discriminants of CM fields, this latter case occuring only in weight 1 when the projective image is D2=C2xC2, i.e., coded 4 by mfgaloistype."},
{"mfisequal",0,(void*)mfisequal,14,"lGGD0,L,","mfisequal(F,G,{lim=0}): Checks whether the modular forms F and G are equal. If lim is nonzero, only check equality of the first lim+1 Fourier coefficients."},
{"mfkohnenbasis",0,(void*)mfkohnenbasis,14,"G","mfkohnenbasis(mf): mf being a cuspidal space of half-integral weight k >= 3/2, gives a basis B of the Kohnen + space of mf as a matrix whose columns are the coefficients of B on the basis of mf."},
{"mfkohnenbijection",0,(void*)mfkohnenbijection,14,"G","mfkohnenbijection(mf): mf being a cuspidal space of half-integral weight returns [mf2,M,K,shi], where M is a matrix giving a Hecke-module isomorphism from S_{2k-1}(N,CHI^2) given by mf2 to the Kohnen + space S_k+(4N,CHI), K is a basis of the Kohnen + space, and shi gives the linear combination of Shimura lifts giving M^(-1)."},
{"mfkohneneigenbasis",0,(void*)mfkohneneigenbasis,14,"GG","mfkohneneigenbasis(mf,bij): mf being a cuspidal space of half-integral weight k >= 3/2 and bij being the output of mfkohnenbijection(mf), outputs a 3-component vector [mf0,BNEW,BEIGEN], where BNEW and BEIGEN are two matrices whose columns are the coefficients of a basis of the Kohnen new space and of the eigenforms on the basis of mf respectively, and mf0 is the corresponding new space of integral weight 2k - 1."},
{"mflinear",0,(void*)mflinear,14,"GG","mflinear(vF,v): vF being a vector of modular forms and v a vector of coefficients of same length, compute the linear combination of the entries of vF with coefficients v."},
{"mfmanin",0,(void*)mfmanin,14,"Gb","mfmanin(FS): Given the modular symbol FS associated to an eigenform F by mfsymbol(mf,F), computes the even and odd special polynomials as well as the even and odd periods om+ and om- as a vector [[P+,P-],[om+,om-,r]], where r = imag(om+*conj(om-))/<F,F>. If F has several embeddings into C, give the vector of results corresponding to each embedding."},
{"mfmul",0,(void*)mfmul,14,"GG","mfmul(F,G): Multiply the two forms F and G."},
{"mfnumcusps",0,(void*)mfnumcusps,14,"G","mfnumcusps(N): number of cusps of Gamma_0(N)"},
{"mfparams",0,(void*)mfparams,14,"G","mfparams(F): If F is a modular form space, returns [N,k,CHI,space]: level, weight, character, and space code. If F is a modular form, returns [N,k,CHI,P], where P is the (polynomial giving the) field of definition of F: in that case the level N may be a multiple of the level of F and the polynomial P may define a larger field than Q(F)."},
{"mfperiodpol",0,(void*)mfperiodpol,14,"GGD0,L,b","mfperiodpol(mf,f,{flag=0}): period polynomial of the cuspidal part of the form f, in other words integral from 0 to ioo of (X-tau)^(k-2)f(tau). If flag=0, ordinary period polynomial, if flag=1 or -1, even or odd part of that polynomial. f can also be the modular symbol output by mfsymbol(mf,f)."},
{"mfperiodpolbasis",0,(void*)mfperiodpolbasis,14,"LD0,L,","mfperiodpolbasis(k,{flag=0}): basis of period polynomials for weight k. If flag=1 or -1, basis of odd or even period polynomials."},
{"mfpetersson",0,(void*)mfpetersson,14,"GDG","mfpetersson(fs,{gs}): Petersson scalar product of the modular forms f and g belonging to the same modular form space mf, given by the corresponding \"modular symbols\" fs and gs output by mfsymbol (also in weight 1 and half-integral weight). If gs is omitted it is understood to be equal to fs. The scalar product is normalized by the factor 1/[G:G_0(N)]."},
{"mfpow",0,(void*)mfpow,14,"GL","mfpow(F,n): compute F^n"},
{"mfsearch",0,(void*)mfsearch,14,"GGD4,L,","mfsearch(NK,V,{space}): NK being of the form [N,k] with k possibly half-integral, search for a modular form with rational coefficients, of weight k and level N, whose initial coefficients a(0),... are equal to V; space specifies the modular form spaces in which to search. The output is a list of matching forms with that given level and weight. Note that the character is of the form (D/.), where D is a (positive or negative) fundamental discriminant dividing N.  N can be replaced by a vector of allowed levels, in which case the list of forms is sorted by increasing level, then increasing |D|. If a form is found at level N, any multiple of N with the same D is not considered  Note that this is very different from mfeigensearch, which only searches for rational eigenforms."},
{"mfshift",0,(void*)mfshift,14,"GL","mfshift(F,s): Divide the form F by q^s omitting the remainder if there is one; s can be negative."},
{"mfshimura",0,(void*)mfshimura,14,"GGD1,L,","mfshimura(mf, F, {D = 1}): F being a modular form of half-integral weight k >= 3/2 and D a (not necessarily fundamental) discriminant of suitable sign, computes the Shimura lift G of weight 2k-1 corresponding to D. This function returns [mf2,G,v], where mf2 is a modular form space containing G, and v the vector of coefficients of G on mf. By extension, D can also be a positive squarefree integer."},
{"mfslashexpansion",0,(void*)mfslashexpansion,14,"GGGLLD&p","mfslashexpansion(mf,f,g,n,flrat,{&params}): g being in M_2^+(Q), computes the Fourier expansion of f|_k g to n terms. f must belong to the space mf. If params is given, it is set to the parameters [alpha,w,A]. If flrat is 1, the program tries to rationalize the expression; if flag is 0, it does not."},
{"mfspace",0,(void*)mfspace,14,"lGDG","mfspace(mf,{f}): identify the modular space mf, resp. the modular form f in mf. Returns 0 (newspace), 1 (cuspidal space), 2 (old space), 3 (Eisenstein space) or 4 (full space). Return -1 when the form does not belong to the space."},
{"mfsplit",0,(void*)mfsplit,14,"GD0,L,D0,L,","mfsplit(mf,{dimlim=0},{flag=0}): mf containing the new space split the new space into Galois orbits of eigenforms of the newspace and return [vF,vK], where vF gives the (Galois orbit of) eigenforms in terms of mfbasis(mf) and vK is a list of polynomials defining each Galois orbit. If dimlim is set only the Galois orbits of dimension <= dimlim are computed (i.e. the rational eigenforms if dimlim = 1 and the character is real). Flag speeds up computations when the dimension is large: if flag = d > 0, when the dimension of the eigenspace is > d, only the Galois polynomial is computed."},
{"mfsturm",0,(void*)mfsturm,14,"lG","mfsturm(NK): Sturm bound for modular forms on G_0(N) and weight k, i.e., an upper bound for the order of the zero at infinity of a nonzero form. NK is either [N,k] or an mfinit (exact bound in the latter case)."},
{"mfsymbol",0,(void*)mfsymbol,14,"GDGb","mfsymbol(mf,f): Initialize data for working with all period polynomials of the modular form f: this is essential for efficiency for functions such as mfsymboleval, mfmanin, and mfpetersson. By abuse of language, initialize data for working with mfpetersson in weight 1 or half-integral weight (where no symbol exist)."},
{"mfsymboleval",0,(void*)mfsymboleval,14,"GGDGb","mfsymboleval(fs,path,{ga=id}): evaluation of the modular symbol fs output by mfsymbol on the given path, where path is either a vector [s1,s2] or an integral matrix [a,b;c,d] representing the path [a/c,b/d]. In both cases, s1 or s2 (or a/c or b/d) can also be elements of the upper half-plane. The result is the polynomial equal to the integral between s1 and s2 of (X-tau)^{k-2}F(tau). If ga in GL_2+(Q) is given, replace F by F|_k ga. If the integral diverges, the result will be a rational function."},
{"mftaylor",0,(void*)mftaylor,14,"GLD0,L,p","mftaylor(F,n,{flreal=0}): F being a modular form in M_k(SL_2(Z)), computes the first n+1 canonical Taylor expansion of F around tau=I. If flreal=0, computes only an algebraic equivalence class. If flreal is set, compute p_n such that for tau close enough to I we have f(tau)=(2I/(tau+I))^ksum_{n>=0}p_n((tau-I)/(tau+I))^n."},
{"mftobasis",0,(void*)mftobasis,14,"GGD0,L,","mftobasis(mf,F,{flag=0}): coefficients of the form F on the basis given by the mfbasis(mf). A q-expansion or vector of coefficients can also be given instead of F, but in this case an error message may occur if the expansion is too short. An error message is also given if F does not belong to the modular form space. If flag is set, instead of error messages return an output as an affine space of solutions if a q-expansion or vector of coefficients is given, or the empty column otherwise."},
{"mftocoset",0,(void*)mftocoset,14,"LGG","mftocoset(N,M,Lcosets): M being a matrix in SL_2(Z) and Lcosets being mfcosets(N), find the right coset of G_0(N) to which M belongs. The output is a pair [ga,i] such that M = ga * Lcosets[i], with ga in G_0(N)."},
{"mftonew",0,(void*)mftonew,14,"GG","mftonew(mf,F): mf being a full or cuspidal space with parameters [N,k,chi] and F a cusp form in that space, returns a vector of 3-component vectors [M,d,G], where f(chi) divides M divides N, d divides N/M, and G is a form in S_k^new(G_0(M),chi) such that F is equal to the sum of the B(d)(G) over all these 3-component vectors."},
{"mftraceform",0,(void*)mftraceform,14,"GD0,L,","mftraceform(NK,{space=0}): If NK=[N,k,CHI,.] as in mfinit with k integral, gives the trace form in the corresponding subspace of S_k(G_0(N),chi). The supported values for space are 0: the newspace (default), 1: the full cuspidal space."},
{"mftwist",0,(void*)mftwist,14,"GG","mftwist(F,D): returns the twist of the form F by the integer D, i.e., the form G such that mfcoef(G,n)=(D/n)mfcoef(F,n), where (D/n) is the Kronecker symbol."},
{"min",0,(void*)gmin,2,"GG","min(x,y): minimum of x and y."},
{"minpoly",0,(void*)minpoly,7,"GDn","minpoly(A,{v='x}): minimal polynomial of the matrix or polmod A."},
{"modreverse",0,(void*)modreverse,10,"G","modreverse(z): reverse polmod of the polmod z, if it exists."},
{"moebius",0,(void*)moebius,5,"lG","moebius(x): Moebius function of x."},
{"msatkinlehner",0,(void*)msatkinlehner,15,"GLDG","msatkinlehner(M,Q,{H}): M being a full modular symbol space of level N, as given by msinit, let Q | N, (Q,N/Q) = 1, and let H be a subspace stable under the Atkin-Lehner involution w_Q. Return the matrix of w_Q acting on H (M if omitted)."},
{"mscuspidal",0,(void*)mscuspidal,15,"GD0,L,","mscuspidal(M, {flag=0}): M being a full modular symbol space, as given by msinit, return its cuspidal part S. If flag = 1, return [S,E] its decomposition into Eisenstein and cuspidal parts."},
{"msdim",0,(void*)msdim,15,"lG","msdim(M): M being a modular symbol space or subspace, return its dimension as a Q-vector space."},
{"mseisenstein",0,(void*)mseisenstein,15,"G","mseisenstein(M): M being a full modular symbol space, as given by msinit, return its Eisenstein subspace."},
{"mseval",0,(void*)mseval,15,"GGDG","mseval(M,s,{p}): M being a full modular symbol space, as given by msinit, s being a modular symbol from M and p being a path between two elements in P^1(Q), return s(p)."},
{"msfromcusp",0,(void*)msfromcusp,15,"GG","msfromcusp(M, c): returns the modular symbol attached to the cusp c, where M is a modular symbol space of level N."},
{"msfromell",0,(void*)msfromell,15,"GD0,L,","msfromell(E, {sign=0}): return the [M, x], where M is msinit(N,2) and x is the modular symbol in M attached to the elliptic curve E/Q."},
{"msfromhecke",0,(void*)msfromhecke,15,"GGDG","msfromhecke(M, v, {H}): given a msinit M and a vector v of pairs [p, P] (where p is prime and P is a polynomial with integer coefficients), return a basis of all modular symbols such that P(Tp) * s = 0. If H is present, it must be a Hecke-stable subspace and we restrict to s in H."},
{"msgetlevel",0,(void*)msgetlevel,15,"lG","msgetlevel(M): M being a full modular symbol space, as given by msinit, return its level N."},
{"msgetsign",0,(void*)msgetsign,15,"lG","msgetsign(M): M being a full modular symbol space, as given by msinit, return its sign."},
{"msgetweight",0,(void*)msgetweight,15,"lG","msgetweight(M): M being a full modular symbol space, as given by msinit, return its weight k."},
{"mshecke",0,(void*)mshecke,15,"GLDG","mshecke(M,p,{H}): M being a full modular symbol space, as given by msinit, p being a prime number, and H being a Hecke-stable subspace (M if omitted), return the matrix of T_p acting on H (U_p if p divides the level)."},
{"msinit",0,(void*)msinit,15,"GGD0,L,","msinit(G, V, {sign=0}): given G a finite index subgroup of SL(2,Z) and a finite dimensional representation V of GL(2,Q), creates a space of modular symbols, the G-module Hom_G(Div^0(P^1 Q), V). This is canonically isomorphic to H^1_c(X(G), V), and allows to compute modular forms for G. If sign is present and non-zero, it must be +1 or -1 and we consider the subspace defined by Ker (Sigma - sign), where Sigma is induced by [-1,0;0,1]. Currently the only supported groups are the Gamma_0(N), coded by the integer N. The only supported representation is V_k = Q[X,Y]_{k-2}, coded by the integer k >= 2."},
{"msissymbol",0,(void*)msissymbol,15,"GG","msissymbol(M,s): M being a full modular symbol space, as given by msinit, check whether s is a modular symbol attached to M."},
{"mslattice",0,(void*)mslattice,15,"GDG","mslattice(M, {H}): M being a full modular symbol space, as given by msinit, H a Q-subspace or a matrix of modular symbols. Return the canonical integral structure of H."},
{"msnew",0,(void*)msnew,15,"G","msnew(M): M being a full modular symbol space, as given by msinit, return its new cuspidal subspace."},
{"msomseval",0,(void*)msomseval,15,"GGG","msomseval(Mp, PHI, path): return the vectors of moments of the p-adic distribution attached to the path 'path' via the overconvergent modular symbol 'PHI'."},
{"mspadicL",0,(void*)mspadicL,15,"GDGD0,L,","mspadicL(mu, {s = 0}, {r = 0}): given mu from mspadicmoments (p-adic distributions attached to an overconvergent symbol PHI) returns the value on a character of Z_p^* represented by s of the derivative of order r of the p-adic L-function attached to PHI."},
{"mspadicinit",0,(void*)mspadicinit,15,"GLLD-1,L,","mspadicinit(M, p, n, {flag}): M being a full modular symbol space, as given by msinit and a prime p, initialize technical data needed to compute with overconvergent modular symbols (modulo p^n). If flag is unset, allow all symbols; if flag = 0, restrict to ordinary symbols; else initialize for symbols phi such that Tp(phi) = a_p * phi, with v_p(a_p) >= flag."},
{"mspadicmoments",0,(void*)mspadicmoments,15,"GGD1,L,","mspadicmoments(Mp, PHI, {D = 1}): given Mp from mspadicinit, an overconvergent eigensymbol PHI, and optionally a fundamental discriminant D coprime to p, return the moments of the p-1 distributions PHI^D([0]-[oo]) | (a + pZp), 0 < a < p. To be used by mspadicL and mspadicseries."},
{"mspadicseries",0,(void*)mspadicseries,15,"GD0,L,","mspadicseries(mu, {i=0}): given mu from mspadicmoments, returns the attached p-adic series with maximal p-adic precision, depending on the precision of M (i-th Teichmueller component, if present)."},
{"mspathgens",0,(void*)mspathgens,15,"G","mspathgens(M): M being a full modular symbol space, as given by msinit, return a set of Z[G]-generators for Div^0(P^1 Q). The output is [g,R], where g is a minimal system of generators and R the vector of Z[G]-relations between the given generators."},
{"mspathlog",0,(void*)mspathlog,15,"GG","mspathlog(M,p): M being a full modular symbol space, as given by msinit and p being a path between two elements in P^1(Q), return (p_i) in Z[G] such that p = \\sum p_i g_i, and the g_i are fixed Z[G]-generators for Div^0(P^1 Q), see mspathgens."},
{"mspetersson",0,(void*)mspetersson,15,"GDGDG","mspetersson(M, {F}, {G=F}): M being a full modular symbol space, as given by msinit, calculate the intersection product {F,G} of modular symbols F and G on M."},
{"mspolygon",0,(void*)mspolygon,15,"GD0,L,","mspolygon(M, {flag = 0}): M being a full modular symbol space, as given by msinit or an integer > 1, return an hyperbolic polygon (Farey symbol) attached to the group Gamma_0(N). Binary digits of flag mean: 1=normalized polygon, 2=also add graphical representations."},
{"msqexpansion",0,(void*)msqexpansion,15,"GGDP","msqexpansion(M,projH,{B = seriesprecision}): M being a full modular symbol space, as given by msinit, and projH being a projector on a Hecke-simple subspace, return the Fourier coefficients [a_n, n <= B] of the corresponding normalized newform. If B omitted, use seriesprecision."},
{"mssplit",0,(void*)mssplit,15,"GDGD0,L,","mssplit(M,{H},{dimlim}): M being a full modular symbol space, as given by msinit, and H being a subspace (the new subspace if omitted), split H into Hecke-simple subspaces. If dimlim is present and positive, restrict to dim <= dimlim."},
{"msstar",0,(void*)msstar,15,"GDG","msstar(M,{H}): M being a full modular symbol space, as given by msinit, return the matrix of the * involution, induced by complex conjugation, acting on the (stable) subspace H (M if omitted)."},
{"mstooms",0,(void*)mstooms,15,"GG","mstooms(Mp, phi): given Mp from mspadicinit, lift the (classical) eigen symbol phi to a distribution-valued overconvergent symbol in the sense of Pollack and Stevens. The resulting overconvergent eigensymbol can then be used in mspadicmoments, then mspadicL or mspadicseries."},
{"my",0,NULL,1,NULL,"my(x,...,z): declare x,...,z as lexically-scoped local variables."},
{"newtonpoly",0,(void*)newtonpoly,10,"GG","newtonpoly(x,p): Newton polygon of polynomial x with respect to the prime p."},
{"next",0,(void*)next0,1,"D1,L,","next({n=1}): interrupt execution of current instruction sequence, and start another iteration from the n-th innermost enclosing loops."},
{"nextprime",0,(void*)nextprime,5,"G","nextprime(x): smallest pseudoprime >= x."},
{"nfalgtobasis",0,(void*)algtobasis,10,"GG","nfalgtobasis(nf,x): transforms the algebraic number x into a column vector on the integral basis nf.zk."},
{"nfbasis",0,(void*)nfbasis_gp,10,"G","nfbasis(T): integral basis of the field Q[a], where a is a root of the polynomial T, using the round 4 algorithm. An argument [T,listP] is possible, where listP is a list of primes (to get an order which is maximal at certain primes only) or a prime bound."},
{"nfbasistoalg",0,(void*)basistoalg,10,"GG","nfbasistoalg(nf,x): transforms the column vector x on the integral basis into an algebraic number."},
{"nfcertify",0,(void*)nfcertify,10,"G","nfcertify(nf): returns a vector of composite integers used to certify nf.zk and nf.disc unconditionally (both are correct when the output is the empty vector)."},
{"nfcompositum",0,(void*)nfcompositum,10,"GGGD0,L,","nfcompositum(nf,P,Q,{flag=0}): vector of all possible compositums of the number fields defined by the polynomials P and Q; flag is optional, whose binary digits mean 1: output for each compositum, not only the compositum polynomial pol, but a vector [R,a,b,k] where a (resp. b) is a root of P (resp. Q) expressed as a polynomial modulo R, and a small integer k such that al2+k*al1 is the chosen root of R; 2: assume that the number fields defined by P and Q are linearly disjoint."},
{"nfdetint",0,(void*)nfdetint,10,"GG","nfdetint(nf,x): multiple of the ideal determinant of the pseudo generating set x."},
{"nfdisc",0,(void*)nfdisc,10,"G","nfdisc(T): discriminant of the number field defined by the polynomial T. An argument [T,listP] is possible, where listP is a list of primes or a prime bound."},
{"nfeltadd",0,(void*)nfadd,10,"GGG","nfeltadd(nf,x,y): element x+y in nf."},
{"nfeltdiv",0,(void*)nfdiv,10,"GGG","nfeltdiv(nf,x,y): element x/y in nf."},
{"nfeltdiveuc",0,(void*)nfdiveuc,10,"GGG","nfeltdiveuc(nf,x,y): gives algebraic integer q such that x-qy is small."},
{"nfeltdivmodpr",0,(void*)nfdivmodpr,10,"GGGG","nfeltdivmodpr(nf,x,y,pr): this function is obsolete, use nfmodpr."},
{"nfeltdivrem",0,(void*)nfdivrem,10,"GGG","nfeltdivrem(nf,x,y): gives [q,r] such that r=x-qy is small."},
{"nfeltembed",0,(void*)nfeltembed,10,"GGDGp","nfeltembed(nf,x,{pl}): complex embeddings of x at places given by vector pl."},
{"nfeltmod",0,(void*)nfmod,10,"GGG","nfeltmod(nf,x,y): gives r such that r=x-qy is small with q algebraic integer."},
{"nfeltmul",0,(void*)nfmul,10,"GGG","nfeltmul(nf,x,y): element x.y in nf."},
{"nfeltmulmodpr",0,(void*)nfmulmodpr,10,"GGGG","nfeltmulmodpr(nf,x,y,pr): this function is obsolete, use nfmodpr."},
{"nfeltnorm",0,(void*)nfnorm,10,"GG","nfeltnorm(nf,x): norm of x."},
{"nfeltpow",0,(void*)nfpow,10,"GGG","nfeltpow(nf,x,k): element x^k in nf."},
{"nfeltpowmodpr",0,(void*)nfpowmodpr,10,"GGGG","nfeltpowmodpr(nf,x,k,pr): this function is obsolete, use nfmodpr."},
{"nfeltreduce",0,(void*)nfreduce,10,"GGG","nfeltreduce(nf,a,id): gives r such that a-r is in the ideal id and r is small."},
{"nfeltreducemodpr",0,(void*)nfreducemodpr,10,"GGG","nfeltreducemodpr(nf,x,pr): this function is obsolete, use nfmodpr."},
{"nfeltsign",0,(void*)nfeltsign,10,"GGDG","nfeltsign(nf,x,{pl}): signs of real embeddings of x at places given by vector pl."},
{"nfelttrace",0,(void*)nftrace,10,"GG","nfelttrace(nf,x): trace of x."},
{"nfeltval",0,(void*)gpnfvalrem,10,"GGGD&","nfeltval(nf,x,pr,{&y}): valuation of element x at the prime pr as output by idealprimedec."},
{"nffactor",0,(void*)nffactor,10,"GG","nffactor(nf,T): factor polynomial T in number field nf."},
{"nffactorback",0,(void*)nffactorback,10,"GGDG","nffactorback(nf,f,{e}): given a factorization f, returns the factored object back as an nf element."},
{"nffactormod",0,(void*)nffactormod,10,"GGG","nffactormod(nf,Q,pr): this routine is obsolete, use nfmodpr and factormod. Factor polynomial Q modulo prime ideal pr in number field nf."},
{"nfgaloisapply",0,(void*)galoisapply,10,"GGG","nfgaloisapply(nf,aut,x): apply the Galois automorphism aut to the object x (element or ideal) in the number field nf."},
{"nfgaloisconj",0,(void*)galoisconj0,10,"GD0,L,DGp","nfgaloisconj(nf,{flag=0},{d}): list of conjugates of a root of the polynomial x=nf.pol in the same number field. flag is optional (set to 0 by default), meaning 0: use combination of flag 4 and 1, always complete; 1: use nfroots; 4: use Allombert's algorithm, complete if the field is Galois of degree <= 35 (see manual for details). nf can be simply a polynomial."},
{"nfgrunwaldwang",0,(void*)nfgrunwaldwang,10,"GGGGDn","nfgrunwaldwang(nf,Lpr,Ld,pl,{v='x}): a polynomial in the variable v defining a cyclic extension of nf (given in nf or bnf form) with local behavior prescribed by Lpr, Ld and pl: the extension has local degree a multiple of Ld[i] at the prime Lpr[i], and the extension is complex at the i-th real place of nf if pl[i]=-1 (no condition if pl[i]=0). The extension has degree the LCM of the local degrees."},
{"nfhilbert",0,(void*)nfhilbert0,10,"lGGGDG","nfhilbert(nf,a,b,{pr}): if pr is omitted, global Hilbert symbol (a,b) in nf, that is 1 if X^2-aY^2-bZ^2 has a non-trivial solution (X,Y,Z) in nf, -1 otherwise. Otherwise compute the local symbol modulo the prime ideal pr."},
{"nfhnf",0,(void*)nfhnf0,10,"GGD0,L,","nfhnf(nf,x,{flag=0}): if x=[A,I], gives a pseudo-basis [B,J] of the module sum A_jI_j. If flag is non-zero, return [[B,J], U], where U is the transformation matrix such that AU = [0|B]."},
{"nfhnfmod",0,(void*)nfhnfmod,10,"GGG","nfhnfmod(nf,x,detx): if x=[A,I], and detx is a multiple of the ideal determinant of x, gives a pseudo-basis of the module sum A_jI_j."},
{"nfinit",0,(void*)nfinit0,10,"GD0,L,p","nfinit(pol,{flag=0}): pol being a nonconstant irreducible polynomial, gives the vector: [pol,[r1,r2],discf,index,[M,MC,T2,T,different] (see manual),r1+r2 first roots, integral basis, matrix of power basis in terms of integral basis, multiplication table of basis]. flag is optional and can be set to 0: default; 1: do not compute different; 2: first use polred to find a simpler polynomial; 3: outputs a two-element vector [nf,Mod(a,P)], where nf is as in 2 and Mod(a,P) is a polmod equal to Mod(x,pol) and P=nf.pol."},
{"nfisideal",0,(void*)isideal,10,"lGG","nfisideal(nf,x): true(1) if x is an ideal in the number field nf, false(0) if not."},
{"nfisincl",0,(void*)nfisincl,10,"GG","nfisincl(f,g): let f and g define number fields, either irreducible rational polynomials or number fields as output by nfinit; tests whether the number field f is isomorphic to a subfield of g. Return 0 if not, and otherwise all the isomorphisms."},
{"nfisisom",0,(void*)nfisisom,10,"GG","nfisisom(f,g): as nfisincl but tests whether f is isomorphic to g."},
{"nfislocalpower",0,(void*)nfislocalpower,10,"lGGGG","nfislocalpower(nf,pr,a,n): true(1) if a is an n-th power in the local field K_v, false(0) if not."},
{"nfkermodpr",0,(void*)nfkermodpr,10,"GGG","nfkermodpr(nf,x,pr): this function is obsolete, use nfmodpr."},
{"nfmodpr",0,(void*)nfmodpr,10,"GGG","nfmodpr(nf,x,pr): map x to the residue field mod pr."},
{"nfmodprinit",0,(void*)nfmodprinit,10,"GG","nfmodprinit(nf,pr): transform the prime ideal pr into modpr format necessary for all operations mod pr in the number field nf."},
{"nfmodprlift",0,(void*)nfmodprlift,10,"GGG","nfmodprlift(nf,x,pr): lift x from residue field mod pr to nf."},
{"nfnewprec",0,(void*)nfnewprec,10,"Gp","nfnewprec(nf): transform the number field data nf into new data using the current (usually larger) precision."},
{"nfpolsturm",0,(void*)nfpolsturm,10,"GGDG","nfpolsturm(nf, T, {pl}): number of distinct real roots of the polynomial s(T) where s runs through the real embeddings given by vector pl."},
{"nfroots",0,(void*)nfroots,10,"DGG","nfroots({nf},x): roots of polynomial x belonging to nf (Q if omitted) without multiplicity."},
{"nfrootsof1",0,(void*)rootsof1,10,"G","nfrootsof1(nf): number of roots of unity and primitive root of unity in the number field nf."},
{"nfsnf",0,(void*)nfsnf0,10,"GGD0,L,","nfsnf(nf,x,{flag=0}): if x=[A,I,J], outputs D=[d_1,...d_n] Smith normal form of x. If flag is non-zero return [D,U,V], where UAV = Id."},
{"nfsolvemodpr",0,(void*)nfsolvemodpr,10,"GGGG","nfsolvemodpr(nf,a,b,P): this function is obsolete, use nfmodpr."},
{"nfsplitting",0,(void*)nfsplitting,10,"GDG","nfsplitting(P,{d}): defining polynomial over Q for the splitting field of P, that is the smallest field over which P is totally split. P can also be given by a nf structure. If d is given, it must be a multiple of the splitting field degree."},
{"nfsubfields",0,(void*)nfsubfields,10,"GD0,L,","nfsubfields(pol,{d=0}): find all subfields of degree d of number field defined by pol (all subfields if d is null or omitted). Result is a vector of subfields, each being given by [g,h], where g is an absolute equation and h expresses one of the roots of g in terms of the root x of the polynomial defining nf."},
{"norm",0,(void*)gnorm,3,"G","norm(x): norm of x."},
{"norml2",0,(void*)gnorml2,7,"G","norml2(x): square of the L2-norm of x."},
{"normlp",0,(void*)gnormlp,7,"GDGp","normlp(x,{p=oo}): Lp-norm of x; sup norm if p is omitted."},
{"numbpart",0,(void*)numbpart,4,"G","numbpart(n): number of partitions of n."},
{"numdiv",0,(void*)numdiv,5,"G","numdiv(x): number of divisors of x."},
{"numerator",0,(void*)numerator,3,"GDG","numerator(f,{D}): numerator of f."},
{"numtoperm",0,(void*)numtoperm,4,"LG","numtoperm(n,k): permutation number k (mod n!) of n letters (n C-integer)."},
{"omega",0,(void*)omega,5,"lG","omega(x): number of distinct prime divisors of x."},
{"oo",0,(void*)mkoo,3,"","oo=oo(): infinity."},
{"padicappr",0,(void*)padicappr,6,"GG","padicappr(pol,a): p-adic roots of the polynomial pol congruent to a mod p."},
{"padicfields",0,(void*)padicfields0,6,"GGD0,L,","padicfields(p, N, {flag=0}): returns polynomials generating all the extensions of degree N of the field of p-adic rational numbers; N is allowed to be a 2-component vector [n,d], in which case, returns the extensions of degree n and discriminant p^d. flag is optional, and can be 0: default, 1: return also the ramification index, the residual degree, the valuation of the discriminant and the number of conjugate fields, or 2: return only the number of extensions in a fixed algebraic closure."},
{"padicprec",0,(void*)gppadicprec,3,"GG","padicprec(x,p): return the absolute p-adic precision of object x."},
{"parapply",0,(void*)parapply,1,"GG","parapply(f, x): parallel evaluation of f on the elements of x."},
{"pareval",0,(void*)pareval,1,"G","pareval(x): parallel evaluation of the elements of the vector of closures x."},
{"parfor",0,(void*)parfor0,1,"vV=GDGJDVDI","parfor(i=a,{b},expr1,{r},{expr2}): evaluates the expression expr1 in parallel for all i between a and b (if b is set to +oo, the loop will not stop), resulting in as many values; if the formal variables r and expr2 are present, evaluate sequentially expr2, in which r has been replaced by the different results obtained for expr1 and i with the corresponding arguments."},
{"parforprime",0,(void*)parforprime0,1,"vV=GDGJDVDI","parforprime(p=a,{b},expr1,{r},{expr2}): evaluates the expression expr1 in parallel for all primes p between a and b (if b is set to +oo, the loop will not stop), resulting in as many values; if the formal variables r and expr2 are present, evaluate sequentially expr2, in which r has been replaced by the different results obtained for expr1 and p with the corresponding arguments."},
{"parforvec",0,(void*)parforvec0,1,"vV=GJDVDID0,L,","parforvec(X=v,expr1,{j},{expr2},{flag}): evaluates the sequence expr2 (dependent on X and j) for X as generated by forvec, in random order, computed in parallel. Substitute for j the value of expr1 (dependent on X)."},
{"parploth",0,(void*)parploth,16,"V=GGJD0,M,D0,L,p\nParametric|1; Recursive|2; no_Rescale|4; no_X_axis|8; no_Y_axis|16; no_Frame|32; no_Lines|64; Points_too|128; Splines|256; no_X_ticks|512; no_Y_ticks|1024; Same_ticks|2048; Complex|4096","parploth(X=a,b,expr,{flags=0},{n=0}): plot of expression expr, X goes from a to b in high resolution. Both flags and n are optional. Binary digits of flags mean: 1=Parametric, 2=Recursive, 4=no_Rescale, 8=no_X_axis, 16=no_Y_axis, 32=no_Frame, 64=no_Lines (do not join points), 128=Points_too (plot both lines and points), 256=Splines (use cubic splines), 512=no_X_ticks, 1024= no_Y_ticks, 2048=Same_ticks (plot all ticks with the same length), 4096=Complex (the two coordinates of each point are encoded as a complex number). n specifies number of reference points on the graph (0=use default value). Returns a vector for the bounding box."},
{"parselect",0,(void*)parselect,1,"GGD0,L,","parselect(f, A, {flag = 0}): (parallel select) selects elements of A according to the selection function f which is tested in parallel. If flag is 1, return the indices of those elements (indirect selection)."},
{"parsum",0,(void*)parsum,1,"V=GGJDG","parsum(i=a,b,expr,{x}): x plus the sum (X goes from a to b) of expression expr, evaluated in parallel (in random order)."},
{"partitions",0,(void*)partitions,4,"LDGDG","partitions(k,{a=k},{n=k}): vector of partitions of the integer k. You can restrict the length of the partitions with parameter n (n=nmax or n=[nmin,nmax]), or the range of the parts with parameter a (a=amax or a=[amin,amax]). By default remove zeros, but one can set amin=0 to get X of fixed length nmax (=k by default)."},
{"parvector",0,(void*)parvector,1,"LVJ","parvector(N,i,expr): as vector(N,i,expr) but the evaluations of expr are done in parallel."},
{"permorder",0,(void*)permorder,4,"lG","permorder(x): order of the permutation x."},
{"permsign",0,(void*)permsign,4,"lG","permsign(x): signature of the permutation x."},
{"permtonum",0,(void*)permtonum,4,"G","permtonum(x): ordinal (between 1 and n!) of permutation x."},
{"plot",0,(void*)pariplot,16,"vV=GGEDGDGp","plot(X=a,b,expr,{Ymin},{Ymax}): crude plot of expression expr, X goes from a to b, with Y ranging from Ymin to Ymax. If Ymin (resp. Ymax) is not given, the minimum (resp. the maximum) of the expression is used instead."},
{"plotbox",0,(void*)plotbox,16,"vLGGD0,L,","plotbox(w,x2,y2,{filled=0}): if the cursor is at position (x1,y1), draw a box with diagonal (x1,y1) and (x2,y2) in rectwindow w (cursor does not move). If filled=1, fill the box."},
{"plotclip",0,(void*)plotclip,16,"vL","plotclip(w): clip the contents of the rectwindow to the bounding box (except strings)."},
{"plotcolor",0,(void*)plotcolor,16,"LG","plotcolor(w,c): in rectwindow w, set default color to c. Possible values for c are [R,G,B] values, a color name or an index in the graphcolormap default: factory settings are 1=black, 2=blue, 3=sienna, 4=red, 5=green, 6=grey, 7=gainsborough. Return [R,G,B] value attached to color."},
{"plotcopy",0,(void*)plotcopy,16,"vLLGGD0,L,","plotcopy(sourcew,destw,dx,dy,{flag=0}): copy the contents of rectwindow sourcew to rectwindow destw with offset (dx,dy). If flag's bit 1 is set, dx and dy express fractions of the size of the current output device, otherwise dx and dy are in pixels. dx and dy are relative positions of northwest corners if other bits of flag vanish, otherwise of: 2: southwest, 4: southeast, 6: northeast corners."},
{"plotcursor",0,(void*)plotcursor,16,"L","plotcursor(w): current position of cursor in rectwindow w."},
{"plotdraw",0,(void*)plotdraw,16,"vGD0,L,","plotdraw(w, {flag=0}): draw rectwindow w. More generally, w can be of the form [w1,x1,y1, w2,x2,y2,etc.]: draw rectwindows wi at given xi,yi positions. If flag!=0, the xi,yi express fractions of the size of the current output device."},
{"plotexport",0,(void*)plotexport,16,"GGD0,L,","plotexport(fmt, list, {flag=0}): draw vector of rectwindows list as in plotdraw, returning the resulting picture as a character string; fmt is either \"ps\" or \"svg\"."},
{"ploth",0,(void*)ploth0,16,"V=GGED0,M,D0,L,p\nParametric|1; Recursive|2; no_Rescale|4; no_X_axis|8; no_Y_axis|16; no_Frame|32; no_Lines|64; Points_too|128; Splines|256; no_X_ticks|512; no_Y_ticks|1024; Same_ticks|2048; Complex|4096","ploth(X=a,b,expr,{flags=0},{n=0}): plot of expression expr, X goes from a to b in high resolution. Both flags and n are optional. Binary digits of flags mean: 1=Parametric, 2=Recursive, 4=no_Rescale, 8=no_X_axis, 16=no_Y_axis, 32=no_Frame, 64=no_Lines (do not join points), 128=Points_too (plot both lines and points), 256=Splines (use cubic splines), 512=no_X_ticks, 1024= no_Y_ticks, 2048=Same_ticks (plot all ticks with the same length), 4096=Complex (the two coordinates of each point are encoded as a complex number). n specifies number of reference points on the graph (0=use default value). Returns a vector for the bounding box."},
{"plothexport",0,(void*)plothexport0,16,"GV=GGED0,M,D0,L,p\nParametric|1; Recursive|2; no_Rescale|4; no_X_axis|8; no_Y_axis|16; no_Frame|32; no_Lines|64; Points_too|128; Splines|256; no_X_ticks|512; no_Y_ticks|1024; Same_ticks|2048; Complex|4096","plothexport(fmt, X=a,b,expr,{flags=0},{n=0}): plot of expression expr, X goes from a to b in high resolution, returning the resulting picture as a character string which can then be written to a file."},
{"plothraw",0,(void*)plothraw,16,"GGD0,L,","plothraw(X,Y,{flag=0}): plot in high resolution points whose x (resp. y) coordinates are in X (resp. Y). If flag is 1, join points, other non-0 flags should be combinations of bits 8,16,32,64,128,256 meaning the same as for ploth()."},
{"plothrawexport",0,(void*)plothrawexport,16,"GGGD0,L,","plothrawexport(fmt, X,Y,{flag=0}): plot in high resolution points whose x (resp. y) coordinates are in X (resp. Y), returning the resulting picture as a character string. If flag is 1, join points, other non-0 flags should be combinations of bits 8,16,32,64,128,256 meaning the same as for ploth()."},
{"plothsizes",0,(void*)plothsizes,16,"D0,L,","plothsizes({flag=0}): returns array of 8 elements: terminal width and height, sizes for ticks in horizontal and vertical directions, width and height of characters, width and height of display (if applicable). If flag=0, sizes of ticks and characters are in pixels, otherwise are fractions of the terminal size."},
{"plotinit",0,(void*)plotinit,16,"vLDGDGD0,L,","plotinit(w,{x},{y},{flag=0}): initialize rectwindow w to size x,y. If flag!=0, x and y express fractions of the size of the current output device. Omitting x or y means use the full size of the device."},
{"plotkill",0,(void*)plotkill,16,"vL","plotkill(w): erase the rectwindow w."},
{"plotlines",0,(void*)plotlines,16,"vLGGD0,L,","plotlines(w,X,Y,{flag=0}): draws an open polygon in rectwindow w where X and Y contain the x (resp. y) coordinates of the vertices. If X and Y are both single values (i.e not vectors), draw the corresponding line (and move cursor). If (optional) flag is non-zero, close the polygon."},
{"plotlinetype",0,(void*)plotlinetype,16,"vLL","plotlinetype(w,type): this function is obsolete; no graphing engine implement this functionality."},
{"plotmove",0,(void*)plotmove,16,"vLGG","plotmove(w,x,y): move cursor to position x,y in rectwindow w."},
{"plotpoints",0,(void*)plotpoints,16,"vLGG","plotpoints(w,X,Y): draws in rectwindow w the points whose x (resp y) coordinates are in X (resp Y). If X and Y are both single values (i.e not vectors), draw the corresponding point (and move cursor)."},
{"plotpointsize",0,(void*)plotpointsize,16,"vLG","plotpointsize(w,size): change the \"size\" of following points in rectwindow w. w=-1 changes global value."},
{"plotpointtype",0,(void*)plotpointtype,16,"vLL","plotpointtype(w,type): this function is obsolete; no graphing engine implement this functionality."},
{"plotrbox",0,(void*)plotrbox,16,"vLGGD0,L,","plotrbox(w,dx,dy,{filled}): if the cursor is at (x1,y1), draw a box with diagonal (x1,y1)-(x1+dx,y1+dy) in rectwindow w (cursor does not move). If filled=1, fill the box."},
{"plotrecth",0,(void*)plotrecth0,16,"LV=GGED0,M,D0,L,p\nParametric|1; Recursive|2; no_Rescale|4; no_X_axis|8; no_Y_axis|16; no_Frame|32; no_Lines|64; Points_too|128; Splines|256; no_X_ticks|512; no_Y_ticks|1024; Same_ticks|2048; Complex|4096","plotrecth(w,X=a,b,expr,{flag=0},{n=0}): writes to rectwindow w the curve output of ploth(w,X=a,b,expr,flag,n). Returns a vector for the bounding box."},
{"plotrecthraw",0,(void*)plotrecthraw,16,"LGD0,L,","plotrecthraw(w,data,{flags=0}): plot graph(s) for data in rectwindow w, where data is a vector of vectors. If plot is parametric, length of data should be even, and pairs of entries give curves to plot. If not, first entry gives x-coordinate, and the other ones y-coordinates. Admits the same optional flags as plotrecth, save that recursive plot is meaningless."},
{"plotrline",0,(void*)plotrline,16,"vLGG","plotrline(w,dx,dy): if the cursor is at (x1,y1), draw a line from (x1,y1) to (x1+dx,y1+dy) (and move the cursor) in the rectwindow w."},
{"plotrmove",0,(void*)plotrmove,16,"vLGG","plotrmove(w,dx,dy): move cursor to position (dx,dy) relative to the present position in the rectwindow w."},
{"plotrpoint",0,(void*)plotrpoint,16,"vLGG","plotrpoint(w,dx,dy): draw a point (and move cursor) at position dx,dy relative to present position of the cursor in rectwindow w."},
{"plotscale",0,(void*)plotscale,16,"vLGGGG","plotscale(w,x1,x2,y1,y2): scale the coordinates in rectwindow w so that x goes from x1 to x2 and y from y1 to y2 (y2<y1 is allowed)."},
{"plotstring",0,(void*)plotstring,16,"vLsD0,L,","plotstring(w,x,{flags=0}): draw in rectwindow w the string corresponding to x. Bits 1 and 2 of flag regulate horizontal alignment: left if 0, right if 2, center if 1. Bits 4 and 8 regulate vertical alignment: bottom if 0, top if 8, v-center if 4. Can insert additional gap between point and string: horizontal if bit 16 is set, vertical if bit 32 is set."},
{"polchebyshev",0,(void*)polchebyshev_eval,6,"LD1,L,DG","polchebyshev(n,{flag=1},{a='x}): Chebychev polynomial of the first (flag = 1) or second (flag = 2) kind, of degree n, evaluated at a."},
{"polclass",0,(void*)polclass,6,"GD0,L,Dn","polclass(D, {inv = 0}, {x = 'x}): return a polynomial generating the Hilbert class field of Q(sqrt(D)) for the discriminant D<0."},
{"polcoef",0,(void*)polcoef,6,"GLDn","polcoef(x,n,{v}): coefficient of degree n of x. With respect to the main variable if v is omitted, with respect to the variable v otherwise."},
{"polcoeff",0,(void*)polcoeff0,6,"GLDn","polcoeff(x,n,{v}): deprecated alias for polcoef."},
{"polcompositum",0,(void*)polcompositum0,10,"GGD0,L,","polcompositum(P,Q,{flag=0}): vector of all possible compositums of the number fields defined by the polynomials P and Q; flag is optional, whose binary digits mean 1: output for each compositum, not only the compositum polynomial pol, but a vector [R,a,b,k] where a (resp. b) is a root of P (resp. Q) expressed as a polynomial modulo R, and a small integer k such that al2+k*al1 is the chosen root of R; 2: assume that the number fields defined by P and Q are linearly disjoint."},
{"polcyclo",0,(void*)polcyclo_eval,6,"LDG","polcyclo(n,{a = 'x}): n-th cyclotomic polynomial evaluated at a."},
{"polcyclofactors",0,(void*)polcyclofactors,6,"G","polcyclofactors(f): returns a vector of polynomials, whose product is the product of distinct cyclotomic polynomials dividing f."},
{"poldegree",0,(void*)gppoldegree,6,"GDn","poldegree(x,{v}): degree of the polynomial or rational function x with respect to main variable if v is omitted, with respect to v otherwise. For scalar x, return 0 if x is non-zero and -oo otherwise."},
{"poldisc",0,(void*)poldisc0,6,"GDn","poldisc(pol,{v}): discriminant of the polynomial pol, with respect to main variable if v is omitted, with respect to v otherwise."},
{"poldiscfactors",0,(void*)poldiscfactors,6,"GD0,L,","poldiscfactors(T,{flag=0}): [D, faD], where D = discriminant of the polynomial T, and faD is a cheap partial factorization of D (entries are coprime but need not be primes); if flag is 1, finish the factorization via factorint."},
{"poldiscreduced",0,(void*)reduceddiscsmith,6,"G","poldiscreduced(f): vector of elementary divisors of Z[a]/f'(a)Z[a], where a is a root of the polynomial f."},
{"polgalois",0,(void*)polgalois,10,"Gp","polgalois(T): Galois group of the polynomial T (see manual for group coding). Return [n, s, k, name] where n is the group order, s the signature, k the index and name is the GAP4 name of the transitive group."},
{"polgraeffe",0,(void*)polgraeffe,6,"G","polgraeffe(f): returns the Graeffe transform g of f, such that g(x^2) = f(x)f(-x)."},
{"polhensellift",0,(void*)polhensellift,6,"GGGL","polhensellift(A, B, p, e): lift the factorization B of A modulo p to a factorization modulo p^e using Hensel lift. The factors in B must be pairwise relatively prime modulo p."},
{"polhermite",0,(void*)polhermite_eval,6,"LDG","polhermite(n,{a='x}): Hermite polynomial H(n,v) of degree n, evaluated at a."},
{"polinterpolate",0,(void*)polint,6,"GDGDGD&","polinterpolate(X,{Y},{t = 'x},{&e}): polynomial interpolation at t according to data vectors X, Y (i.e. given P of minimal degree such that P(X[i]) = Y[i] for all i, return P(t)). If Y is omitted, take P such that P(i) = X[i]. If present, e will contain an error estimate on the returned value."},
{"poliscyclo",0,(void*)poliscyclo,6,"lG","poliscyclo(f): returns 0 if f is not a cyclotomic polynomial, and n > 0 if f = Phi_n, the n-th cyclotomic polynomial."},
{"poliscycloprod",0,(void*)poliscycloprod,6,"lG","poliscycloprod(f): returns 1 if f is a product of cyclotomic polynonials, and 0 otherwise."},
{"polisirreducible",0,(void*)isirreducible,6,"lG","polisirreducible(pol): true(1) if pol is an irreducible non-constant polynomial, false(0) if pol is reducible or constant."},
{"pollead",0,(void*)pollead,6,"GDn","pollead(x,{v}): leading coefficient of polynomial or series x, or x itself if x is a scalar. Error otherwise. With respect to the main variable of x if v is omitted, with respect to the variable v otherwise."},
{"pollegendre",0,(void*)pollegendre_eval,6,"LDG","pollegendre(n,{a='x}): legendre polynomial of degree n evaluated at a."},
{"polmodular",0,(void*)polmodular,6,"LD0,L,DGDnD0,L,","polmodular(L, {inv = 0}, {x = 'x}, {y = 'y}, {derivs = 0}): return the modular polynomial of level L and invariant inv."},
{"polrecip",0,(void*)polrecip,6,"G","polrecip(pol): reciprocal polynomial of pol."},
{"polred",0,(void*)polred0,10,"GD0,L,DG","polred(T,{flag=0}): deprecated, use polredbest. Reduction of the polynomial T (gives minimal polynomials only). The following binary digits of (optional) flag are significant 1: partial reduction, 2: gives also elements."},
{"polredabs",0,(void*)polredabs0,10,"GD0,L,","polredabs(T,{flag=0}): a smallest generating polynomial of the number field for the T2 norm on the roots, with smallest index for the minimal T2 norm. flag is optional, whose binary digit mean 1: give the element whose characteristic polynomial is the given polynomial. 4: give all polynomials of minimal T2 norm (give only one of P(x) and P(-x))."},
{"polredbest",0,(void*)polredbest,10,"GD0,L,","polredbest(T,{flag=0}): reduction of the polynomial T (gives minimal polynomials only). If flag=1, gives also elements."},
{"polredord",0,(void*)polredord,10,"G","polredord(x): this function is obsolete, use polredbest."},
{"polresultant",0,(void*)polresultant0,6,"GGDnD0,L,","polresultant(x,y,{v},{flag=0}): resultant of the polynomials x and y, with respect to the main variables of x and y if v is omitted, with respect to the variable v otherwise. flag is optional, and can be 0: default, uses either the subresultant algorithm, a modular algorithm or Sylvester's matrix, depending on the inputs; 1 uses Sylvester's matrix (should always be slower than the default)."},
{"polresultantext",0,(void*)polresultantext0,6,"GGDn","polresultantext(A,B,{v}): return [U,V,R] such that R=polresultant(A,B,v) and U*A+V*B = R, where A and B are polynomials."},
{"polroots",0,(void*)roots,6,"Gp","polroots(T): complex roots of the polynomial T using Schonhage's method, as modified by Gourdon."},
{"polrootsbound",0,(void*)polrootsbound,6,"GDG","polrootsbound(T, {tau = 0.01}): return a sharp upper bound for the modulus of the largest complex root of the polynomial T with relative error tau."},
{"polrootsff",0,(void*)polrootsff,6,"GDGDG","polrootsff(x,{p},{a}): obsolete, use polrootsmod."},
{"polrootsmod",0,(void*)polrootsmod,6,"GDG","polrootsmod(f,{D}): roots of the polynomial f over the finite field defined by the domain D."},
{"polrootspadic",0,(void*)rootpadic,6,"GGL","polrootspadic(x,p,r): p-adic roots of the polynomial x to precision r."},
{"polrootsreal",0,(void*)realroots,6,"GDGp","polrootsreal(T, {ab}): real roots of the polynomial T with real coefficients, using Uspensky's method. In interval ab = [a,b] if present."},
{"polsturm",0,(void*)sturmpart,6,"lGDGDG","polsturm(T,{ab}): number of distinct real roots of the polynomial T (in the interval ab = [a,b] if present)."},
{"polsubcyclo",0,(void*)polsubcyclo,6,"LLDn","polsubcyclo(n,d,{v='x}): finds an equation (in variable v) for the d-th degree subfields of Q(zeta_n). Output is a polynomial, or a vector of polynomials if there are several such fields or none."},
{"polsylvestermatrix",0,(void*)sylvestermatrix,6,"GG","polsylvestermatrix(x,y): forms the sylvester matrix attached to the two polynomials x and y. Warning: the polynomial coefficients are in columns, not in rows."},
{"polsym",0,(void*)polsym,6,"GL","polsym(x,n): column vector of symmetric powers of the roots of x up to n."},
{"poltchebi",0,(void*)polchebyshev1,6,"LDn","poltchebi(n,{v='x}): deprecated alias for polchebyshev."},
{"poltschirnhaus",0,(void*)tschirnhaus,10,"G","poltschirnhaus(x): random Tschirnhausen transformation of the polynomial x."},
{"polylog",0,(void*)polylog0,8,"LGD0,L,p","polylog(m,x,{flag=0}): m-th polylogarithm of x. flag is optional, and can be 0: default, 1: D_m~-modified m-th polylog of x, 2: D_m-modified m-th polylog of x, 3: P_m-modified m-th polylog of x."},
{"polzagier",0,(void*)polzag,6,"LL","polzagier(n,m): Zagier's polynomials of index n,m."},
{"powers",0,(void*)gpowers0,2,"GLDG","powers(x,n,{x0}): return the vector [1,x,...,x^n] if x0 is omitted, and [x0, x0*x, ..., x0*x^n] otherwise."},
{"precision",0,(void*)precision0,3,"GD0,L,","precision(x,{n}): if n is present, return x at precision n. If n is omitted, return real precision of object x."},
{"precprime",0,(void*)precprime,5,"G","precprime(x): largest pseudoprime <= x, 0 if x<=1."},
{"prime",0,(void*)prime,5,"L","prime(n): returns the n-th prime (n C-integer)."},
{"primecert",0,(void*)primecert,5,"GD0,L,","primecert(N, {flag=0}): If N is a prime, return a Primality Certificate. Return 0 otherwise. If flag = 0 return an ECPP certificate (Atkin-Morain); if flag = 1 return an N-1 certificate (Pocklington-Lehmer)"},
{"primecertexport",0,(void*)primecertexport,5,"GD0,L,","primecertexport(cert, {format = 0}): Returns a string suitable for print/write to display a primality certificate."},
{"primecertisvalid",0,(void*)primecertisvalid,5,"lG","primecertisvalid(cert): Verifies if cert is a valid PARI ECPP Primality certificate."},
{"primepi",0,(void*)primepi,5,"G","primepi(x): the prime counting function pi(x) = #{p <= x, p prime}."},
{"primes",0,(void*)primes0,5,"G","primes(n): returns the vector of the first n primes (integer), or the primes in interval n = [a,b]."},
{"print",0,(void*)print,1,"vs*","print({str}*): outputs its string arguments (in raw format) ending with a newline."},
{"print1",0,(void*)print1,1,"vs*","print1({str}*): outputs its string arguments (in raw format) without ending with newline."},
{"printf",0,(void*)printf0,1,"vss*","printf(fmt,{x}*): prints its arguments according to the format fmt."},
{"printp",0,(void*)printp,1,"vs*","printp({str}*): outputs its string arguments (in prettymatrix format) ending with a newline."},
{"printsep",0,(void*)printsep,1,"vss*","printsep(sep,{str}*): outputs its string arguments (in raw format), separated by 'sep', ending with a newline."},
{"printsep1",0,(void*)printsep1,1,"vss*","printsep1(sep,{str}*): outputs its string arguments (in raw format), separated by 'sep', without ending with a newline."},
{"printtex",0,(void*)printtex,1,"vs*","printtex({str}*): outputs its string arguments in TeX format."},
{"prod",0,(void*)produit,9,"V=GGEDG","prod(X=a,b,expr,{x=1}): x times the product (X runs from a to b) of expression."},
{"prodeuler",0,(void*)prodeuler0,9,"V=GGEp","prodeuler(X=a,b,expr): Euler product (X runs over the primes between a and b) of real or complex expression."},
{"prodeulerrat",0,(void*)prodeulerrat,9,"GDGD2,L,p","prodeulerrat(F,{s=1},{a=2}): product from primes p = a to infinity of F(p^s), where F is a rational function."},
{"prodinf",0,(void*)prodinf0,9,"V=GED0,L,p","prodinf(X=a,expr,{flag=0}): infinite product (X goes from a to infinity) of real or complex expression. flag can be 0 (default) or 1, in which case compute the product of the 1+expr instead."},
{"prodnumrat",0,(void*)prodnumrat,9,"GLp","prodnumrat(F,a): product from n = a to infinity of F(n), where F-1 is a rational function of degree less than or equal to -2."},
{"psdraw",0,(void*)psdraw,16,"vGD0,L,","psdraw(list, {flag=0}): obsolete function."},
{"psi",0,(void*)gpsi,8,"Gp","psi(x): psi-function at x."},
{"psploth",0,(void*)psploth0,16,"V=GGED0,L,D0,L,p","psploth(X=a,b,expr,{flags=0},{n=0}): obsolete function."},
{"psplothraw",0,(void*)psplothraw,16,"GGD0,L,","psplothraw(listx,listy,{flag=0}): obsolete function."},
{"qfauto",0,(void*)qfauto0,7,"GDG","qfauto(G,{fl}): automorphism group of the positive definite quadratic form G."},
{"qfautoexport",0,(void*)qfautoexport,7,"GD0,L,","qfautoexport(qfa,{flag}): qfa being an automorphism group as output by qfauto, output a string representing the underlying matrix group in GAP notation (default) or Magma notation (flag = 1)."},
{"qfbclassno",0,(void*)qfbclassno0,5,"GD0,L,","qfbclassno(D,{flag=0}): class number of discriminant D using Shanks's method by default. If (optional) flag is set to 1, use Euler products."},
{"qfbcompraw",0,(void*)qfbcompraw,5,"GG","qfbcompraw(x,y): Gaussian composition without reduction of the binary quadratic forms x and y."},
{"qfbhclassno",0,(void*)hclassno,5,"G","qfbhclassno(x): Hurwitz-Kronecker class number of x>0."},
{"qfbil",0,(void*)qfbil,7,"GGDG","qfbil(x,y,{q}): this function is obsolete, use qfeval."},
{"qfbnucomp",0,(void*)nucomp,5,"GGG","qfbnucomp(x,y,L): composite of primitive positive definite quadratic forms x and y using nucomp and nudupl, where L=[|D/4|^(1/4)] is precomputed."},
{"qfbnupow",0,(void*)nupow,5,"GGDG","qfbnupow(x,n,{L}): n-th power of primitive positive definite quadratic form x using nucomp and nudupl."},
{"qfbpowraw",0,(void*)qfbpowraw,5,"GL","qfbpowraw(x,n): n-th power without reduction of the binary quadratic form x."},
{"qfbprimeform",0,(void*)primeform,5,"GGp","qfbprimeform(x,p): returns the prime form of discriminant x, whose first coefficient is p."},
{"qfbred",0,(void*)qfbred0,5,"GD0,L,DGDGDG","qfbred(x,{flag=0},{d},{isd},{sd}): reduction of the binary quadratic form x. All other args. are optional. The arguments d, isd and sd, if present, supply the values of the discriminant, floor(sqrt(d)) and sqrt(d) respectively. If d<0, its value is not used and all references to Shanks's distance hereafter are meaningless. flag can be any of 0: default, uses Shanks's distance function d; 1: use d, do a single reduction step; 2: do not use d; 3: do not use d, single reduction step."},
{"qfbredsl2",0,(void*)qfbredsl2,5,"GDG","qfbredsl2(x,{data}): reduction of the binary quadratic form x, return [y,g] where y is reduced and g in Sl(2,Z) is such that g.x = y; data, if present, must be equal to [D, sqrtint(D)], where D > 0 is the discriminant of x."},
{"qfbsolve",0,(void*)qfbsolve,5,"GG","qfbsolve(Q,p): return [x,y] so that Q(x,y)=p where Q is a binary quadratic form and p a prime number, or 0 if there is no solution."},
{"qfeval",0,(void*)qfeval0,7,"DGGDG","qfeval({q},x,{y}): evaluate the quadratic form q (symmetric matrix) at x; if y is present, evaluate the polar form at (x,y); if q omitted, use the standard Euclidean form."},
{"qfgaussred",0,(void*)qfgaussred,7,"G","qfgaussred(q): square reduction of the (symmetric) matrix q (returns a square matrix whose i-th diagonal term is the coefficient of the i-th square in which the coefficient of the i-th variable is 1)."},
{"qfisom",0,(void*)qfisom0,7,"GGDGDG","qfisom(G,H,{fl},{grp}): find an isomorphism between the integral positive definite quadratic forms G and H if it exists. G can also be given by a qfisominit structure which is preferable if several forms need to be compared to G."},
{"qfisominit",0,(void*)qfisominit0,7,"GDGDG","qfisominit(G,{fl},{m}): G being a square and symmetric matrix representing an integral positive definite quadratic form, this function returns a structure allowing to compute isomorphisms between G and other quadratic form faster."},
{"qfjacobi",0,(void*)jacobi,7,"Gp","qfjacobi(A): eigenvalues and orthogonal matrix of eigenvectors of the real symmetric matrix A."},
{"qflll",0,(void*)qflll0,7,"GD0,L,","qflll(x,{flag=0}): LLL reduction of the vectors forming the matrix x (gives the unimodular transformation matrix T such that x*T is LLL-reduced). flag is optional, and can be 0: default, 1: assumes x is integral, 2: assumes x is integral, returns a partially reduced basis, 4: assumes x is integral, returns [K,T] where K is the integer kernel of x and T the LLL reduced image, 5: same as 4 but x may have polynomial coefficients, 8: same as 0 but x may have polynomial coefficients."},
{"qflllgram",0,(void*)qflllgram0,7,"GD0,L,","qflllgram(G,{flag=0}): LLL reduction of the lattice whose gram matrix is G (gives the unimodular transformation matrix). flag is optional and can be 0: default,1: assumes x is integral, 4: assumes x is integral, returns [K,T],  where K is the integer kernel of x and T the LLL reduced image, 5: same as 4 but x may have polynomial coefficients, 8: same as 0 but x may have polynomial coefficients."},
{"qfminim",0,(void*)qfminim0,7,"GDGDGD0,L,p","qfminim(x,{b},{m},{flag=0}): x being a square and symmetric matrix representing a positive definite quadratic form, this function deals with the vectors of x whose norm is less than or equal to b, enumerated using the Fincke-Pohst algorithm, storing at most m vectors (no limit if m is omitted). The function searches for the minimal non-zero vectors if b is omitted. The precise behavior depends on flag. 0: returns at most 2m vectors (unless m omitted), returns [N,M,mat] where N is the number of vectors enumerated, M the maximum norm among these, and mat lists half the vectors (the other half is given by -mat). 1: ignores m and returns the first vector whose norm is less than b. 2: as 0 but uses a more robust, slower implementation, valid for non integral quadratic forms."},
{"qfnorm",0,(void*)qfnorm,7,"GDG","qfnorm(x,{q}): this function is obsolete, use qfeval."},
{"qforbits",0,(void*)qforbits,7,"GG","qforbits(G,V): return the orbits of V under the action of the group of linear transformation generated by the set G, which must stabilize V."},
{"qfparam",0,(void*)qfparam,7,"GGD0,L,","qfparam(G, sol, {flag = 0}): coefficients of binary quadratic forms that parametrize the solutions of the ternary quadratic form G, using the particular solution sol."},
{"qfperfection",0,(void*)perf,7,"G","qfperfection(G): rank of matrix of xx~ for x minimal vectors of a gram matrix G."},
{"qfrep",0,(void*)qfrep0,7,"GGD0,L,","qfrep(q,B,{flag=0}): vector of (half) the number of vectors of norms from 1 to B for the integral and definite quadratic form q. If flag is 1, count vectors of even norm from 1 to 2B."},
{"qfsign",0,(void*)qfsign,7,"G","qfsign(x): signature of the symmetric matrix x."},
{"qfsolve",0,(void*)qfsolve,7,"G","qfsolve(G): solve over Q the quadratic equation X^t G X = 0, where G is a symmetric matrix."},
{"quadclassunit",0,(void*)quadclassunit0,5,"GD0,L,DGp","quadclassunit(D,{flag=0},{tech=[]}): compute the structure of the class group and the regulator of the quadratic field of discriminant D. See manual for the optional technical parameters."},
{"quaddisc",0,(void*)quaddisc,5,"G","quaddisc(x): discriminant of the quadratic field Q(sqrt(x))."},
{"quadgen",0,(void*)quadgen0,5,"GDn","quadgen(D,{v = 'w}): standard generator g of quadratic order of discriminant D. If v is given, the variable name is used to display g, else 'w' is used."},
{"quadhilbert",0,(void*)quadhilbert,5,"Gp","quadhilbert(D): relative equation for the Hilbert class field of the quadratic field of discriminant D (which can also be a bnf)."},
{"quadpoly",0,(void*)quadpoly0,5,"GDn","quadpoly(D,{v='x}): quadratic polynomial corresponding to the discriminant D, in variable v."},
{"quadray",0,(void*)quadray,5,"GGp","quadray(D,f): relative equation for the ray class field of conductor f for the quadratic field of discriminant D (which can also be a bnf)."},
{"quadregulator",0,(void*)quadregulator,5,"Gp","quadregulator(x): regulator of the real quadratic field of discriminant x."},
{"quadunit",0,(void*)quadunit0,5,"GDn","quadunit(D,{v = 'w}): fundamental unit u of the quadratic field of discriminant D where D must be positive. If v is given, the variable name is used to display u, else 'w' is used."},
{"ramanujantau",0,(void*)ramanujantau,5,"G","ramanujantau(n): compute the value of Ramanujan's tau function at n, assuming the GRH. Algorithm in O(n^{1/2+eps})."},
{"random",0,(void*)genrand,3,"DG","random({N=2^31}): random object, depending on the type of N. Integer between 0 and N-1 (t_INT), int mod N (t_INTMOD), element in a finite field (t_FFELT), point on an elliptic curve (ellinit mod p or over a finite field)."},
{"randomprime",0,(void*)randomprime,5,"DG","randomprime({N = 2^31}): returns a strong pseudo prime in [2, N-1]."},
{"read",0,(void*)gp_read_file,1,"D\"\",s,","read({filename}): read from the input file filename. If filename is omitted, reread last input file, be it from read() or \\r."},
{"readstr",0,(void*)readstr,1,"D\"\",s,","readstr({filename}): returns the vector of GP strings containing the lines in filename."},
{"readvec",0,(void*)gp_readvec_file,1,"D\"\",s,","readvec({filename}): create a vector whose components are the evaluation of all the expressions found in the input file filename."},
{"real",0,(void*)greal,3,"G","real(x): real part of x."},
{"removeprimes",0,(void*)removeprimes,5,"DG","removeprimes({x=[]}): remove primes in the vector x from the prime table. x can also be a single integer. List the current extra primes if x is omitted."},
{"return",0,(void*)return0,1,"DG","return({x=0}): return from current subroutine with result x."},
{"rnfalgtobasis",0,(void*)rnfalgtobasis,10,"GG","rnfalgtobasis(rnf,x): relative version of nfalgtobasis, where rnf is a relative numberfield."},
{"rnfbasis",0,(void*)rnfbasis,10,"GG","rnfbasis(bnf,M): given a projective Z_K-module M as output by rnfpseudobasis or rnfsteinitz, gives either a basis of M if it is free, or an n+1-element generating set."},
{"rnfbasistoalg",0,(void*)rnfbasistoalg,10,"GG","rnfbasistoalg(rnf,x): relative version of nfbasistoalg, where rnf is a relative numberfield."},
{"rnfcharpoly",0,(void*)rnfcharpoly,10,"GGGDn","rnfcharpoly(nf,T,a,{var='x}): characteristic polynomial of a over nf, where a belongs to the algebra defined by T over nf. Returns a polynomial in variable var (x by default)."},
{"rnfconductor",0,(void*)rnfconductor,10,"GG","rnfconductor(bnf,T): conductor of the Abelian extension of bnf defined by T. The result is [conductor,bnr,subgroup], where conductor is the conductor itself, bnr the attached bnr structure, and subgroup the HNF defining the norm group (Artin or Takagi group) on the given generators bnr.gen."},
{"rnfdedekind",0,(void*)rnfdedekind,10,"GGDGD0,L,","rnfdedekind(nf,pol,{pr},{flag=0}): relative Dedekind criterion over the number field K, represented by nf, applied to the order O_K[X]/(P), modulo the prime ideal pr (at all primes if pr omitted, in which case flag is automatically set to 1). P is assumed to be monic, irreducible, in O_K[X]. Returns [max,basis,v], where basis is a pseudo-basis of the enlarged order, max is 1 iff this order is pr-maximal, and v is the valuation at pr of the order discriminant. If flag is set, just return 1 if the order is maximal, and 0 if not."},
{"rnfdet",0,(void*)rnfdet,10,"GG","rnfdet(nf,M): given a pseudo-matrix M, compute its determinant."},
{"rnfdisc",0,(void*)rnfdiscf,10,"GG","rnfdisc(nf,T): given a polynomial T with coefficients in nf, gives a 2-component vector [D,d], where D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2."},
{"rnfeltabstorel",0,(void*)rnfeltabstorel,10,"GG","rnfeltabstorel(rnf,x): transforms the element x from absolute to relative representation."},
{"rnfeltdown",0,(void*)rnfeltdown0,10,"GGD0,L,","rnfeltdown(rnf,x,{flag=0}): expresses x on the base field if possible; returns an error otherwise."},
{"rnfeltnorm",0,(void*)rnfeltnorm,10,"GG","rnfeltnorm(rnf,x): returns the relative norm N_{L/K}(x), as an element of K."},
{"rnfeltreltoabs",0,(void*)rnfeltreltoabs,10,"GG","rnfeltreltoabs(rnf,x): transforms the element x from relative to absolute representation."},
{"rnfelttrace",0,(void*)rnfelttrace,10,"GG","rnfelttrace(rnf,x): returns the relative trace Tr_{L/K}(x), as an element of K."},
{"rnfeltup",0,(void*)rnfeltup0,10,"GGD0,L,","rnfeltup(rnf,x,{flag=0}): expresses x (belonging to the base field) on the relative field. As a t_POLMOD if flag = 0 and as a t_COL on the absolute field integer basis if flag = 1."},
{"rnfequation",0,(void*)rnfequation0,10,"GGD0,L,","rnfequation(nf,pol,{flag=0}): given a pol with coefficients in nf, gives an absolute equation z of the number field defined by pol. flag is optional, and can be 0: default, or non-zero, gives [z,al,k], where z defines the absolute equation L/Q as in the default behavior, al expresses as an element of L a root of the polynomial defining the base field nf, and k is a small integer such that t = b + k al is a root of z, for b a root of pol."},
{"rnfhnfbasis",0,(void*)rnfhnfbasis,10,"GG","rnfhnfbasis(bnf,x): given an order x as output by rnfpseudobasis, gives either a true HNF basis of the order if it exists, zero otherwise."},
{"rnfidealabstorel",0,(void*)rnfidealabstorel,10,"GG","rnfidealabstorel(rnf,x): transforms the ideal x from absolute to relative representation."},
{"rnfidealdown",0,(void*)rnfidealdown,10,"GG","rnfidealdown(rnf,x): finds the intersection of the ideal x with the base field."},
{"rnfidealfactor",0,(void*)rnfidealfactor,10,"GG","rnfidealfactor(rnf,x): factor the ideal x into prime ideals in the number field nfinit(rnf)."},
{"rnfidealhnf",0,(void*)rnfidealhnf,10,"GG","rnfidealhnf(rnf,x): relative version of idealhnf, where rnf is a relative numberfield."},
{"rnfidealmul",0,(void*)rnfidealmul,10,"GGG","rnfidealmul(rnf,x,y): relative version of idealmul, where rnf is a relative numberfield."},
{"rnfidealnormabs",0,(void*)rnfidealnormabs,10,"GG","rnfidealnormabs(rnf,x): absolute norm of the ideal x."},
{"rnfidealnormrel",0,(void*)rnfidealnormrel,10,"GG","rnfidealnormrel(rnf,x): relative norm of the ideal x."},
{"rnfidealprimedec",0,(void*)rnfidealprimedec,10,"GG","rnfidealprimedec(rnf,pr): return prime ideal decomposition of the maximal ideal pr of K in L/K; pr is also allowed to be a prime number p, in which case return a pair of vectors [SK,SL], where SK contains the primes of K above p and SL[i] is the vector of primes of L above SK[i]."},
{"rnfidealreltoabs",0,(void*)rnfidealreltoabs0,10,"GGD0,L,","rnfidealreltoabs(rnf,x,{flag=0}): transforms the ideal x from relative to absolute representation. As a vector of t_POLMODs if flag = 0 and as an ideal in HNF in the absolute field if flag = 1."},
{"rnfidealtwoelt",0,(void*)rnfidealtwoelement,10,"GG","rnfidealtwoelt(rnf,x): relative version of idealtwoelt, where rnf is a relative numberfield."},
{"rnfidealup",0,(void*)rnfidealup0,10,"GGD0,L,","rnfidealup(rnf,x,{flag=0}): lifts the ideal x (of the base field) to the relative field. As a vector of t_POLMODs if flag = 0 and as an ideal in HNF in the absolute field if flag = 1."},
{"rnfinit",0,(void*)rnfinit0,10,"GGD0,L,","rnfinit(nf,T,{flag=0}): T being an irreducible polynomial defined over the number field nf, initializes a vector of data necessary for working in relative number fields (rnf functions). See manual for technical details."},
{"rnfisabelian",0,(void*)rnfisabelian,10,"lGG","rnfisabelian(nf,T): T being a relative polynomial with coefficients in nf, return 1 if it defines an abelian extension, and 0 otherwise."},
{"rnfisfree",0,(void*)rnfisfree,10,"lGG","rnfisfree(bnf,x): given an order x as output by rnfpseudobasis or rnfsteinitz, outputs true (1) or false (0) according to whether the order is free or not."},
{"rnfislocalcyclo",0,(void*)rnfislocalcyclo,10,"lG","rnfislocalcyclo(rnf): true(1) if the l-extension attached to rnf is locally cyclotomic (locally contained in the Z_l extension of K_v at all places v | l), false(0) if not."},
{"rnfisnorm",0,(void*)rnfisnorm,10,"GGD0,L,","rnfisnorm(T,a,{flag=0}): T is as output by rnfisnorminit applied to L/K. Tries to tell whether a is a norm from L/K. Returns a vector [x,q] where a=Norm(x)*q. Looks for a solution which is a S-integer, with S a list of places in K containing the ramified primes, generators of the class group of ext, as well as those primes dividing a. If L/K is Galois, omit flag, otherwise it is used to add more places to S: all the places above the primes p <= flag (resp. p | flag) if flag > 0 (resp. flag < 0). The answer is guaranteed (i.e a is a norm iff q=1) if L/K is Galois or, under GRH, if S contains all primes less than 12.log(disc(M))^2, where M is the normal closure of L/K."},
{"rnfisnorminit",0,(void*)rnfisnorminit,10,"GGD2,L,","rnfisnorminit(pol,polrel,{flag=2}): let K be defined by a root of pol, L/K the extension defined by polrel. Compute technical data needed by rnfisnorm to solve norm equations Nx = a, for x in L, and a in K. If flag=0, do not care whether L/K is Galois or not; if flag = 1, assume L/K is Galois; if flag = 2, determine whether L/K is Galois."},
{"rnfkummer",0,(void*)rnfkummer,10,"GDGD0,L,p","rnfkummer(bnr,{subgp},{d=0}): bnr being as output by bnrinit, finds a relative equation for the class field corresponding to the module in bnr and the given congruence subgroup (the ray class field if subgp is omitted). d can be zero (default), or positive, and in this case the output is the list of all relative equations of degree d for the given bnr, with the same conductor as (bnr, subgp)."},
{"rnflllgram",0,(void*)rnflllgram,10,"GGGp","rnflllgram(nf,pol,order): given a pol with coefficients in nf and an order as output by rnfpseudobasis or similar, gives [[neworder],U], where neworder is a reduced order and U is the unimodular transformation matrix."},
{"rnfnormgroup",0,(void*)rnfnormgroup,10,"GG","rnfnormgroup(bnr,pol): norm group (or Artin or Takagi group) corresponding to the Abelian extension of bnr.bnf defined by pol, where the module corresponding to bnr is assumed to be a multiple of the conductor. The result is the HNF defining the norm group on the generators in bnr.gen."},
{"rnfpolred",0,(void*)rnfpolred,10,"GGp","rnfpolred(nf,pol): given a pol with coefficients in nf, finds a list of relative polynomials defining some subfields, hopefully simpler."},
{"rnfpolredabs",0,(void*)rnfpolredabs,10,"GGD0,L,","rnfpolredabs(nf,pol,{flag=0}): given an irreducible pol with coefficients in nf, finds a canonical relative polynomial defining the same field. Binary digits of flag mean: 1: return also the element whose characteristic polynomial is the given polynomial, 2: return an absolute polynomial, 16: partial reduction."},
{"rnfpolredbest",0,(void*)rnfpolredbest,10,"GGD0,L,","rnfpolredbest(nf,pol,{flag=0}): given a pol with coefficients in nf, finds a relative polynomial P defining the same field, hopefully simpler than pol; flag can be 0: default, 1: return [P,a], where a is a root of pol 2: return an absolute polynomial Pabs, 3: return [Pabs, a,b], where a is a root of nf.pol and b is a root of pol."},
{"rnfpseudobasis",0,(void*)rnfpseudobasis,10,"GG","rnfpseudobasis(nf,T): given an irreducible polynomial T with coefficients in nf, returns [A,J,D,d] where [A,J] is a pseudo basis of the maximal order of the extension, D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2."},
{"rnfsteinitz",0,(void*)rnfsteinitz,10,"GG","rnfsteinitz(nf,x): given an order x as output by rnfpseudobasis, gives [A,I,D,d] where (A,I) is a pseudo basis where all the ideals except perhaps the last are trivial."},
{"round",0,(void*)round0,3,"GD&","round(x,{&e}): take the nearest integer to all the coefficients of x. If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits."},
{"select",0,(void*)select0,1,"GGD0,L,","select(f, A, {flag = 0}): selects elements of A according to the selection function f. If flag is 1, return the indices of those elements (indirect selection)."},
{"self",0,(void*)pari_self,1,"m","self(): return the calling function or closure. Useful for defining anonymous recursive functions."},
{"seralgdep",0,(void*)seralgdep,7,"GLL","seralgdep(s,p,r): find a linear relation between powers (1,s, ..., s^p) of the series s, with polynomial coefficients of degree <= r."},
{"serchop",0,(void*)serchop,3,"GD0,L,","serchop(s,{n=0}): remove all terms of degree strictly less than n in series s."},
{"serconvol",0,(void*)convol,6,"GG","serconvol(x,y): convolution (or Hadamard product) of two power series."},
{"serlaplace",0,(void*)laplace,6,"G","serlaplace(x): replaces the power series sum of a_n*x^n/n! by sum of a_n*x^n. For the reverse operation, use serconvol(x,exp(X))."},
{"serprec",0,(void*)gpserprec,3,"Gn","serprec(x,v): return the absolute precision x with respect to power series in the variable v."},
{"serreverse",0,(void*)serreverse,6,"G","serreverse(s): reversion of the power series s."},
{"setbinop",0,(void*)setbinop,7,"GGDG","setbinop(f,X,{Y}): the set {f(x,y), x in X, y in Y}. If Y is omitted, assume that X = Y and that f is symmetric."},
{"setintersect",0,(void*)setintersect,7,"GG","setintersect(x,y): intersection of the sets x and y."},
{"setisset",0,(void*)setisset,7,"lG","setisset(x): true(1) if x is a set (row vector with strictly increasing entries), false(0) if not."},
{"setminus",0,(void*)setminus,7,"GG","setminus(x,y): set of elements of x not belonging to y."},
{"setrand",0,(void*)setrand,1,"vG","setrand(n): reset the seed of the random number generator to n."},
{"setsearch",0,(void*)setsearch,7,"lGGD0,L,","setsearch(S,x,{flag=0}): determines whether x belongs to the set (or sorted list) S. If flag is 0 or omitted, returns 0 if it does not, otherwise returns the index j such that x==S[j]. If flag is non-zero, return 0 if x belongs to S, otherwise the index j where it should be inserted."},
{"setunion",0,(void*)setunion,7,"GG","setunion(x,y): union of the sets x and y."},
{"shift",0,(void*)gshift,2,"GL","shift(x,n): shift x left n bits if n>=0, right -n bits if n<0."},
{"shiftmul",0,(void*)gmul2n,2,"GL","shiftmul(x,n): multiply x by 2^n (n>=0 or n<0)."},
{"sigma",0,(void*)sumdivk,5,"GD1,L,","sigma(x,{k=1}): sum of the k-th powers of the divisors of x. k is optional and if omitted is assumed to be equal to 1."},
{"sign",0,(void*)gsigne,2,"iG","sign(x): sign of x, of type integer, real or fraction."},
{"simplify",0,(void*)simplify,3,"G","simplify(x): simplify the object x as much as possible."},
{"sin",0,(void*)gsin,8,"Gp","sin(x): sine of x."},
{"sinc",0,(void*)gsinc,8,"Gp","sinc(x): sinc function of x."},
{"sinh",0,(void*)gsinh,8,"Gp","sinh(x): hyperbolic sine of x."},
{"sizebyte",0,(void*)gsizebyte,3,"lG","sizebyte(x): number of bytes occupied by the complete tree of the object x."},
{"sizedigit",0,(void*)sizedigit,3,"lG","sizedigit(x): rough upper bound for the number of decimal digits of (the components of) x. DEPRECATED."},
{"solve",0,(void*)zbrent0,9,"V=GGEp","solve(X=a,b,expr): real root of expression expr (X between a and b), where expr(a)*expr(b)<=0."},
{"solvestep",0,(void*)solvestep0,9,"V=GGGED0,L,p","solvestep(X=a,b,step,expr,{flag=0}): find zeros of a function in the real interval [a,b] by naive interval splitting."},
{"sqr",0,(void*)gsqr,8,"G","sqr(x): square of x. NOT identical to x*x."},
{"sqrt",0,(void*)gsqrt,8,"Gp","sqrt(x): square root of x."},
{"sqrtint",0,(void*)sqrtint,5,"G","sqrtint(x): integer square root of x, where x is a non-negative integer."},
{"sqrtn",0,(void*)gsqrtn,8,"GGD&p","sqrtn(x,n,{&z}): nth-root of x, n must be integer. If present, z is set to a suitable root of unity to recover all solutions. If it was not possible, z is set to zero."},
{"sqrtnint",0,(void*)sqrtnint,5,"GL","sqrtnint(x,n): integer n-th root of x, where x is non-negative integer."},
{"stirling",0,(void*)stirling,4,"LLD1,L,","stirling(n,k,{flag=1}): if flag=1 (default) return the Stirling number of the first kind s(n,k), if flag=2, return the Stirling number of the second kind S(n,k)."},
{"subgrouplist",0,(void*)subgrouplist0,10,"GDGD0,L,","subgrouplist(bnr,{bound},{flag=0}): bnr being as output by bnrinit or a list of cyclic components of a finite Abelian group G, outputs the list of subgroups of G (of index bounded by bound, if not omitted), given as HNF left divisors of the SNF matrix corresponding to G. If flag=0 (default) and bnr is as output by bnrinit, gives only the subgroups for which the modulus is the conductor."},
{"subst",0,(void*)gsubst,6,"GnG","subst(x,y,z): in expression x, replace the variable y by the expression z."},
{"substpol",0,(void*)gsubstpol,6,"GGG","substpol(x,y,z): in expression x, replace the polynomial y by the expression z, using remainder decomposition of x."},
{"substvec",0,(void*)gsubstvec,6,"GGG","substvec(x,v,w): in expression x, make a best effort to replace the variables v1,...,vn by the expression w1,...,wn."},
{"sum",0,(void*)somme,9,"V=GGEDG","sum(X=a,b,expr,{x=0}): x plus the sum (X goes from a to b) of expression expr."},
{"sumalt",0,(void*)sumalt0,9,"V=GED0,L,p","sumalt(X=a,expr,{flag=0}): Cohen-Villegas-Zagier's acceleration of alternating series expr, X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials."},
{"sumdedekind",0,(void*)sumdedekind,5,"GG","sumdedekind(h,k): Dedekind sum attached to h,k."},
{"sumdigits",0,(void*)sumdigits0,5,"GDG","sumdigits(n,{B=10}): sum of digits in the integer |n|, when written in base B."},
{"sumdiv",0,(void*)sumdivexpr,9,"GVE","sumdiv(n,X,expr): sum of expression expr, X running over the divisors of n."},
{"sumdivmult",0,(void*)sumdivmultexpr,9,"GVE","sumdivmult(n,d,expr): sum of multiplicative function expr, d running over the divisors of n."},
{"sumeulerrat",0,(void*)sumeulerrat,9,"GDGD2,L,p","sumeulerrat(F,{s=1},{a=2}): sum from primes p = a to infinity of F(p^s), where F is a rational function."},
{"sumformal",0,(void*)sumformal,6,"GDn","sumformal(f,{v}): formal sum of f with respect to v, or to the main variable of f if v is omitted."},
{"suminf",0,(void*)suminf0,9,"V=GEp","suminf(X=a,expr): infinite sum (X goes from a to infinity) of real or complex expression expr."},
{"sumnum",0,(void*)sumnum0,9,"V=GEDGp","sumnum(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Euler-MacLaurin summation. Assume that f corresponds to a series with positive terms and is a C^oo function; a must be an integer, and tab, if given, is the output of sumnuminit."},
{"sumnumap",0,(void*)sumnumap0,9,"V=GEDGp","sumnumap(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Abel-Plana formula. Assume that f is holomorphic in the right half-plane Re(z) > a; a must be an integer, and tab, if given, is the output of sumnumapinit."},
{"sumnumapinit",0,(void*)sumnumapinit,9,"DGp","sumnumapinit({asymp}): initialize tables for Abel-Plana summation of a series."},
{"sumnuminit",0,(void*)sumnuminit,9,"DGp","sumnuminit({asymp}): initialize tables for Euler-MacLaurin delta summation of a series with positive terms."},
{"sumnumlagrange",0,(void*)sumnumlagrange0,9,"V=GEDGp","sumnumlagrange(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Lagrange summation. a must be an integer, and tab, if given, is the output of sumnumlagrangeinit."},
{"sumnumlagrangeinit",0,(void*)sumnumlagrangeinit,9,"DGDGp","sumnumlagrangeinit({asymp}, {c1}): initialize tables for Lagrange summation of a series."},
{"sumnummonien",0,(void*)sumnummonien0,9,"V=GEDGp","sumnummonien(n=a,f,{tab}): numerical summation from n = a to +infinity using Monien summation."},
{"sumnummonieninit",0,(void*)sumnummonieninit,9,"DGDGDGp","sumnummonieninit({asymp},{w},{n0 = 1}): initialize tables for Monien summation of a series with positive terms."},
{"sumnumrat",0,(void*)sumnumrat,9,"GGp","sumnumrat(F,a): sum from n = a to infinity of F(n), where F is a rational function of degree less than or equal to -2."},
{"sumpos",0,(void*)sumpos0,9,"V=GED0,L,p","sumpos(X=a,expr,{flag=0}): sum of positive (or negative) series expr, the formal variable X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials."},
{"system",0,(void*)gpsystem,1,"vs","system(str): str being a string, execute the system command str."},
{"tan",0,(void*)gtan,8,"Gp","tan(x): tangent of x."},
{"tanh",0,(void*)gtanh,8,"Gp","tanh(x): hyperbolic tangent of x."},
{"taylor",0,(void*)tayl,6,"GnDP","taylor(x,t,{d=seriesprecision}): taylor expansion of x with respect to t, adding O(t^d) to all components of x."},
{"teichmuller",0,(void*)teichmuller,8,"GDG","teichmuller(x,{tab}): teichmuller character of p-adic number x. If x = [p,n], return the lifts of all teichmuller(i + O(p^n)) for i = 1, ..., p-1. Such a vector can be fed back to teichmuller, as the optional argument tab, to speed up later computations."},
{"theta",0,(void*)theta,8,"GGp","theta(q,z): Jacobi sine theta-function."},
{"thetanullk",0,(void*)thetanullk,8,"GLp","thetanullk(q,k): k-th derivative at z=0 of theta(q,z)."},
{"thue",0,(void*)thue,6,"GGDG","thue(tnf,a,{sol}): solve the equation P(x,y)=a, where tnf was created with thueinit(P), and sol, if present, contains the solutions of Norm(x)=a modulo units in the number field defined by P. If tnf was computed without assuming GRH (flag 1 in thueinit), the result is unconditional. If tnf is a polynomial, compute thue(thueinit(P,0), a)."},
{"thueinit",0,(void*)thueinit,6,"GD0,L,p","thueinit(P,{flag=0}): initialize the tnf corresponding to P, that will be used to solve Thue equations P(x,y) = some-integer. If flag is non-zero, certify the result unconditionaly. Otherwise, assume GRH (much faster of course)."},
{"trace",0,(void*)gtrace,7,"G","trace(x): trace of x."},
{"trap",0,(void*)trap0,1,"DrDEDE","trap({e}, {rec}, seq): this function is obsolete, use \"iferr\". Try to execute seq, trapping runtime error e (all of them if e omitted); sequence rec is executed if the error occurs and is the result of the command."},
{"truncate",0,(void*)trunc0,3,"GD&","truncate(x,{&e}): truncation of x; when x is a power series,take away the O(X^). If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits."},
{"type",0,(void*)type0,1,"G","type(x): return the type of the GEN x."},
{"uninline",0,NULL,1,NULL,"uninline(): forget all inline variables [EXPERIMENTAL]."},
{"until",0,(void*)untilpari,1,"vEI","until(a,seq): evaluate the expression sequence seq until a is nonzero."},
{"valuation",0,(void*)gpvaluation,3,"GG","valuation(x,p): valuation of x with respect to p."},
{"varhigher",0,(void*)varhigher,3,"sDn","varhigher(name,{v}): return a variable 'name' whose priority is higher than the priority of v (of all existing variables if v is omitted)."},
{"variable",0,(void*)gpolvar,3,"DG","variable({x}): main variable of object x. Gives p for p-adic x, 0 if no variable can be attached to x. Returns the list of user variables if x is omitted."},
{"variables",0,(void*)variables_vec,3,"DG","variables({x}): all variables occuring in object x, sorted by decreasing priority. Returns the list of user variables if x is omitted."},
{"varlower",0,(void*)varlower,3,"sDn","varlower(name,{v}): return a variable 'name' whose priority is lower than the priority of v (of all existing variables if v is omitted."},
{"vecextract",0,(void*)extract0,7,"GGDG","vecextract(x,y,{z}): extraction of the components of the matrix or vector x according to y and z. If z is omitted, y represents columns, otherwise y corresponds to rows and z to columns. y and z can be vectors (of indices), strings (indicating ranges as in \"1..10\") or masks (integers whose binary representation indicates the indices to extract, from left to right 1, 2, 4, 8, etc.)."},
{"vecmax",0,(void*)vecmax0,2,"GD&","vecmax(x,{&v}): largest entry in the vector/matrix x. If v is present, set it to the index of a largest entry (indirect max)."},
{"vecmin",0,(void*)vecmin0,2,"GD&","vecmin(x,{&v}): smallest entry in the vector/matrix x. If v is present, set it to the index of a smallest entry (indirect min)."},
{"vecprod",0,(void*)vecprod,7,"G","vecprod(v): return the product of the components of the vector v."},
{"vecsearch",0,(void*)vecsearch,7,"lGGDG","vecsearch(v,x,{cmpf}): determines whether x belongs to the sorted vector v. If the comparison function cmpf is explicitly given, assume that v was sorted according to vecsort(, cmpf)."},
{"vecsort",0,(void*)vecsort0,7,"GDGD0,L,","vecsort(x,{cmpf},{flag=0}): sorts the vector of vectors (or matrix) x in ascending order, according to the comparison function cmpf, if not omitted. (If cmpf is an integer k, sort according to the value of the k-th component of each entry.) Binary digits of flag (if present) mean: 1: indirect sorting, return the permutation instead of the permuted vector, 4: use descending instead of ascending order, 8: remove duplicate entries."},
{"vecsum",0,(void*)vecsum,7,"G","vecsum(v): return the sum of the components of the vector v."},
{"vector",0,(void*)vecteur,7,"GDVDE","vector(n,{X},{expr=0}): row vector with n components of expression expr (X ranges from 1 to n). By default, fill with 0s."},
{"vectorsmall",0,(void*)vecteursmall,7,"GDVDE","vectorsmall(n,{X},{expr=0}): VECSMALL with n components of expression expr (X ranges from 1 to n) which must be small integers. By default, fill with 0s."},
{"vectorv",0,(void*)vvecteur,7,"GDVDE","vectorv(n,{X},{expr=0}): column vector with n components of expression expr (X ranges from 1 to n). By default, fill with 0s."},
{"version",0,(void*)pari_version,1,"","version(): returns the PARI version as [major,minor,patch] or [major,minor,patch,VCSversion]."},
{"warning",0,(void*)warning0,1,"vs*","warning({str}*): display warning message str."},
{"weber",0,(void*)weber0,8,"GD0,L,p","weber(x,{flag=0}): one of Weber's f function of x. flag is optional, and can be 0: default, function f(x)=exp(-i*Pi/24)*eta((x+1)/2)/eta(x), 1: function f1(x)=eta(x/2)/eta(x) 2: function f2(x)=sqrt(2)*eta(2*x)/eta(x). Note that j = (f^24-16)^3/f^24 = (f1^24+16)^3/f1^24 = (f2^24+16)^3/f2^24."},
{"while",0,(void*)whilepari,1,"vEI","while(a,seq): while a is nonzero evaluate the expression sequence seq. Otherwise 0."},
{"write",0,(void*)write0,1,"vss*","write(filename,{str}*): appends the remaining arguments (same output as print) to filename."},
{"write1",0,(void*)write1,1,"vss*","write1(filename,{str}*): appends the remaining arguments (same output as print1) to filename."},
{"writebin",0,(void*)gpwritebin,1,"vsDG","writebin(filename,{x}): write x as a binary object to file filename. If x is omitted, write all session variables."},
{"writetex",0,(void*)writetex,1,"vss*","writetex(filename,{str}*): appends the remaining arguments (same format as print) to filename, in TeX format."},
{"zeta",0,(void*)gzeta,8,"Gp","zeta(s): Riemann zeta function at s with s a complex or a p-adic number."},
{"zetahurwitz",0,(void*)zetahurwitz,8,"GGD0,L,b","zetahurwitz(s,x,{der=0}): Hurwitz zeta function at s, x, with s not 1 and x not a negative or zero integer. s can be a scalar, polynomial, rational function, or power series. If der>0, compute the der'th derivative with respect to s."},
{"zetamult",0,(void*)zetamult0,8,"GDGp","zetamult(s, {T}): multiple zeta value at integral s = [s1,...,sk]; if given, T is the output of zetamultinit."},
{"zetamultall",0,(void*)zetamultall,8,"Lp","zetamultall(n): list of all multiple zeta values for weight up to n."},
{"zetamultconvert",0,(void*)zetamultconvert,8,"GD1,L,","zetamultconvert(a,{fl=1}): a being either an evec, avec, or index m, converts into evec (fl=0), avec (fl=1), or index m (fl=2)."},
{"zetamultinit",0,(void*)zetamultinit,8,"Lp","zetamultinit(maxw): initialize data to compute multiple zeta values at integral s = [s1,...,sk] for s1 + ... + sk <= maxw."},
{"znchar",0,(void*)znchar,5,"G","znchar(D): given a datum D describing a group G = (Z/NZ)^* and a Dirichlet character chi, return the pair [G,chi]."},
{"zncharconductor",0,(void*)zncharconductor,5,"GG","zncharconductor(G,chi): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)*. Return the conductor of chi."},
{"znchardecompose",0,(void*)znchardecompose,5,"GGG","znchardecompose(G, chi, Q): given a znstar G = (Z/NZ)^* and a Dirichlet character chi, return the product of local characters chi_p for p | (N,Q)."},
{"znchargauss",0,(void*)znchargauss,5,"GGDGb","znchargauss(G, chi, {a=1}): given a Dirichlet character chi on G = (Z/NZ)^*, return the complex Gauss sum g(chi,a)."},
{"zncharinduce",0,(void*)zncharinduce,5,"GGG","zncharinduce(G, chi, N): let G be znstar(q,1), let chi be a Dirichlet character mod q and let N be a multiple of q. Return the character modulo N extending chi."},
{"zncharisodd",0,(void*)zncharisodd,5,"lGG","zncharisodd(G, chi): let G be znstar(N,1), let chi be a Dirichlet character mod N, return 1 if and only if chi(-1) = -1 and 0 otherwise."},
{"znchartokronecker",0,(void*)znchartokronecker,5,"GGD0,L,","znchartokronecker(G, chi, {flag=0}): let G be znstar(N,1), let chi be a Dirichlet character mod N, return the discriminant D if chi is real equal to the Kronecker symbol (D/.) and 0 otherwise. If flag is set, return the fundamental discriminant attached to the corresponding primitive character."},
{"znchartoprimitive",0,(void*)znchartoprimitive,5,"GG","znchartoprimitive(G,chi): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)* of conductor q0. Return [G0,chi0], where chi0 is the primitive character attached to chi and G0 is znstar(q0)."},
{"znconreychar",0,(void*)znconreychar,5,"GG","znconreychar(G,m): Dirichlet character attached to m in (Z/qZ)* in Conrey's notation, where G is znstar(q,1)."},
{"znconreyconductor",0,(void*)znconreyconductor,5,"GGD&","znconreyconductor(G,chi, {&chi0}): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)* given by its Conrey logarithm. Return the conductor of chi, and set chi0 to (the Conrey logarithm of) the attached primitive character. If chi0 != chi, return the conductor and its factorization."},
{"znconreyexp",0,(void*)znconreyexp,5,"GG","znconreyexp(G, chi): Conrey exponential attached to G = znstar(q, 1). Returns the element m in (Z/qZ)^* attached to the character chi on G: znconreylog(G, m) = chi."},
{"znconreylog",0,(void*)znconreylog,5,"GG","znconreylog(G,m): Conrey logarithm attached to m in (Z/qZ)*, where G is znstar(q,1)."},
{"zncoppersmith",0,(void*)zncoppersmith,5,"GGGDG","zncoppersmith(P, N, X, {B=N}): finds all integers x with |x| <= X such that  gcd(N, P(x)) >= B. X should be smaller than exp((log B)^2 / (deg(P) log N))."},
{"znlog",0,(void*)znlog0,5,"GGDG","znlog(x,g,{o}): return the discrete logarithm of x in (Z/nZ)* in base g. If present, o represents the multiplicative order of g. Return [] if no solution exist."},
{"znorder",0,(void*)znorder,5,"GDG","znorder(x,{o}): order of the integermod x in (Z/nZ)*. Optional o represents a multiple of the order of the element."},
{"znprimroot",0,(void*)znprimroot,5,"G","znprimroot(n): returns a primitive root of n when it exists."},
{"znstar",0,(void*)znstar0,5,"GD0,L,","znstar(n,{flag=0}): 3-component vector v = [no,cyc,gen], giving the structure of the abelian group (Z/nZ)^*; no is the order (i.e. eulerphi(n)), cyc is a vector of cyclic components, and gen is a vector giving the corresponding generators."},
{NULL,0,NULL,0,NULL,NULL} /* sentinel */
};
