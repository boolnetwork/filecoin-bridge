Bug numbers refer to the BTS at http://pari.math.u-bordeaux.fr/Bugs/

Done for version 2.11.2 (released 12/05/2019):
  Fixed
      1- make ellheight(E, torsion point) return an exact 0 [#2109]       [F45]
BA    2- hyperellcharpoly: wrong results over Z/3Z                        [F46]
      3- gmp kernel: off-by-1 error in red_mongomery [read uninitialized  [F47]
         memory, then ignores result]
      4- intnuminit([-1,-1/2],[1,-1/2]) twice slower than it should       [F48]
      5- forcomposite(n=2,4,print(n)) -> empty [#2096]                    [F49]
FB    6- [Configure] library not found despite --with-readline-lib [#2097][F53]
      7- minpoly(Mod(1,t^2)) -> SEGV [#2102]                              [F55]
      8- a=ffgen(3^2,'a);poldisc(x^6+a*x+y) -> division by 0 [ positive   [F56]
         characteristic with a few t_INT coefficients ]
BA    9- [pthread] parapply could crash                                   [F58]
BA   10- ffinvmap(m) could SEGV on bad input                              [F59]
     11- ellisdivisible(E/K number field in 'x) -> incorrect priority     [F60]
     12- idealispower(nf, t_INT n) possibly wrong if (n, nf.disc) > 1     [F61]
     13- zeta''(0): all precision lost [more generally f'...'(n quotes)
        imprecise in the neighbourhood of 0, while derivnum(,n) was OK]   [F62]
     14- sumdigits(negative number, B) sometimes negative                 [F63]
     15- poldiscfactors(x^0) -> division by 0                             [F64]
     16- factormod(x^3+1,[y^2+1,2]) -> SEGV                               [F65]
     17- factormod(x^3+1,[y^2+1,5]) -> weird error message                [F66]
BA   18- fix inefficiency in fplll not present in original code           [F69]
     19- polrootsreal(x^4+2*x^3+x^2/3+x/100-1/2000,[1/100,oo]): no root   [F70]
     20- polrootsreal(x^4+2*x^3+x^2/3+x/100-1/1000,[1/10,oo]): extra root [F71]
     21- lfun may crash on lfuncreate input with too short an vector      [F72]
BA   22- incorrect use of graphcolors -> SEGV                             [F73]
     23- forcomposite(..., oo, ) was not supported                        [F74]
BA   24- lfunartin with poles: incorrect result                           [F75]
JD   25- factor: significant pointers lost [#2125]                        [F76]
BA   26- matdet/matrank over large fields was inefficient                 [F77]
     27- poldisc(y^2/x + 1, y) -> error [also affects polresultant]       [F78]
     28- poldisc(x^2/y + 1, y) -> 0 [also affects polresultant]           [F79]
     29- ispower(2, 2^64) -> error                                        [F80]
     30- (f(x) = x*'y); f'(1) -> error                                    [F81]
BA   31- sqrtn(Mod(3,19),4) -> no error [#2127]                           [F82]
     32- nfhnfmod: wrong result                                           [F83]
     33- matdet(mat with t_RFRAC entries): wrong result [#2128]           [F84]
     34- n-th derivative of zetahurwitz used 'seriesprecision' instead
         of n + imprecise value when n large [#2130]                      [F85]
     35- lfunzeros(f, [0, b]) wasn't allowed                              [F86]
     36- mateigen(): typo causing wrong results when correct results were
        achievable [#2131]                                                [F87]
     37- intnum(x=-oo,[0,-1/2],1/sqrt(-x*(x^4+1))) -> division by 0       [F88]
     38- printtex(quadgen(-3,'z)) ==> w                                   [F90]
BA   39- [a,b]=a could lead to memory corruption                          [F91]
     40- memory leak in cgetalloc when lg overflows                       [F92]
     41- possible SEGV in padicappr [#2133]                               [F93]
     42- core() could destroy its input, if stored in a GP variable       [F96]
     43- quadgen(2^64+1) * 1. => junk (stack corruption in quad_disc).    [F97]
     44- ellmoddegree: infinite loop and stack corruption (e.g on 52a2)   [F98]
     45- ellmoddegree(ellinit("10890ba6")) -> wrong result                [F99]
     46- nfgcd called ZX_resultant(a,T) with typ(a) == t_INT             [F100]

Done for version 2.11.1 (released 1/12/2018):
  Fixed
      1- heap-buffer-overflow in init_prefix [readline]                    [F4]
      2- mfsplit(mf,,flag) could return uninitialized objects => SEGV      [F5]
      3- mfeisenstein(k,,chi) was treated as E(k,chi) instead of E(k,1,chi)[F6]
      4- poldegree(y/x) -> 0 [ instead of -1 ]                             [F7]
      5- sumeulerrat(y/x^2,1) -> junk                                      [F8]
HC    6- incgam(-1000.4,2) -> SEGV                                         [F9]
      7- mfatkininit(mfinit([366,2]),2) -> precision error                [F10]
      8- forprimestep: wrong when wrapping over word boundary [#2071]     [F11]
      9- mfbracket: [f,g]_m was multiplied by (-1)^m                      [F12]
     10- wrong results in mfatkininit / mfatkineigenvalues [#2073/#2074]  [F13]
     11- issquare(Mod(x,ffinit(3,2))) -> wrong result [broken Fq_ispower] [F14]
     12- possible SEGV in rnfpseudobasis(, [pol,lim])                     [F15]
     13- wrong result in elllog over F_p, p in [2^63,2^64[                [F16]
     14- wrong result in mfsymboleval when path extremities are close to  [F17]
         real axis (cusps were OK) [#2075]
     15- mfcoefs(mfDelta(),0) -> SEGV [#2078]                             [F18]
     16- GC error in lfuncreate(elliptic curve over number field) [#2080] [F19]
     17- X11 and Qt graphic engine: pari_close called too soon => crash   [F20]
     18- pariold.h: mix up with obsoleted  taille / taille2               [F21]
     19- foo(n)=vector(n)[1..n];123; would corrupt the GP interpreter     [F22]
     20- Pol(0)/'x -> t_INT 0 (instead of 0*x^0)                          [F23]
         Pol(0)/(Mod(1,2)*'x) -> t_INT 0 (instead of Mod(0,2)*x^0)
     21- missing typecheck in nfalgtobasis [#2084]                        [F24]
     22- dbllog2(t_COMPLEX of t_FRAC) => junk                             [F25]
     23- nffactor(t_POL, t_POL) => bug in LLL_cmbf [#2083]                [F26]
     24- ideallog(pure archimedean conductor, t_FRAC) -> log(0) error     [F27]
     25- lfunrootres: avoid oo-loop                                       [F28]
     26- mfgaloistype: dihedral forms possibly incorrect for N > 3000     [F29]
     27- mfgaloistype: error on mf=mfinit([1159,1,Mod(930,1159)],0);      [F30]
     28- hash_GEN(x) differed depending on whether x was a clone          [F33]
BA   29- [mpi] setting nbthreads in .gprc could lead to crashes.          [F34]
     30- accuracy too large in derivnum => slowdown                       [F35]
     31- nfisincl(x^5-x^4+x^3-2*x^2+3*x-1,x^20+x^15+x^10+x^5+1) -> SEGV   [F36]
     32- stack corruption in addsub_frac                                  [F37]
AP   33- segfault in rnfidealup [#2093]                                   [F38]
     34- Ser(x,x,0) -> error instead of O(x) [#2092]                      [F39]
     35- fix mspolygon(,2) [add 1/3rd hyperbolic triangles + fix labels]  [F40]
     36- factor(3/(x^5+3*y*x^4+3*y^2*x^3+y^3*x^2)) -> SEGV                [F41]
     37- catastrophic cancellation in acosh / asinh for large t_COMPLEX   [F43]
     38- zeta(1/2 + I*t) => internal error                                [F44]
